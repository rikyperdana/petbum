Script started on Jum 22 Jun 2018 10:15:34  WIB
]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ nano cobadeh 
[?1049h[1;29r(B[m[4l[?7h[?1h=[?1h=[?1h=[39;49m[?25l[39;49m(B[m[H[2J[29;55H(B[0;7m[ Reading File ][3d(B[m[29;61H(B[0;7m 0 lines[3d(B[m[?12l[?25h[H[39;49m(B[0;7m  GNU nano 2.5.3                             File: cobadeh                                                                  [3;1H(B[m[29d[J[124G[29;1H[?1049l[?1l>]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ l
both.ls  client.ls  cobadeh  [0m[01;34mfolder[0m/  [01;34mnode_modules[0m/  package.json  package-lock.json  README.md  server.ls  stop
]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ rm cobadeh 
]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ l
both.ls  client.ls  [0m[01;34mfolder[0m/  [01;34mnode_modules[0m/  package.json  package-lock.json  README.md  server.ls  stop
]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ git diff
[?1h=[1mdiff --git a/folder/funcs.ls b/folder/funcs.ls[m[m
[1mindex b8dc714..c5349fc 100644[m[m
[1m--- a/folder/funcs.ls[m[m
[1m+++ b/folder/funcs.ls[m[m
[36m@@ -33,7 +33,7 @@[m [mif Meteor.isClient[m[m
                                        e.preventDefault![m[m
                                        temp = state.temp[opts.id]map (i) -> "#{i.name}": i.value[m[m
                                        filtered = _.filter e.target, (i) ->[m[m
[31m-                                               a = -> (i.value isnt \on) and i.name[m[m
[32m+[m                                               [32ma = -> i.value isnt \on and i.name[m[m
                                                b = -> theSchema(i)?autoform?type in <[radio checkbox select]>[m[m
                                                a! and not b![m[m
                                        obj = _.merge ... temp.concat _.map filtered, ({name, value}) -> if name[m[m
[36m@@ -48,7 +48,7 @@[m [mif Meteor.isClient[m[m
                                                                theSchema(normed)?autoValue name, temp.concat filtered[m[m
                                        makeArr = (name, value) ->[m[m
                                                if value is Object value then "#name":[m[m
[31m-                                                       if value[0][m[m
[32m+[m                                                       [32mif value.0[m[m
                                                                Object.keys value .map (key) ->[m[m
                                                                        makeArr key, value[key][m[m
                                                        else if value.getMonth then value[m[m
[36m@@ -83,19 +83,19 @@[m [mif Meteor.isClient[m[m
                        radio: (name, value) ->[m[m
                                type: \radio, name: name, id: "#name#value"[m[m
                                checked: value is (stateTempGet(name)?value or opts.doc?[name])[m[m
[31m-                               oncreate: -> $("input:radio##name#value[name='#name']")on do[m[m
[31m-                                       \change, -> state.temp[opts.id]push {name, value}[m[m
:[K[K[K:[K[K:[K[K[7mNo next tag  (press RETURN)[27m[29;1H[K[K:[K[K:[K[K:[K[K[?1l>]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ q[Kgit status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	[31mmodified:   folder/funcs.ls[m

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	[31mnode_modules/graceful-fs/[m
	[31mnode_modules/is-promise/[m
	[31mnode_modules/lodash/[m
	[31mnode_modules/lowdb/[m
	[31mnode_modules/pify/[m
	[31mnode_modules/steno/[m
	[31mstop[m

no changes added to commit (use "git add" and/or "git commit -a")
]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ git he[K[K--help
usage: git [--version] [--help] [-C <path>] [-c name=value]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common history
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Forward-port local commits to the updated upstream head
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help <command>' or 'git help <concept>'
to read about a specific subcommand or concept.
]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ qnan[K[K[K[Knano both.ls 
[?1049h[1;29r(B[m[4l[?7h[?1h=[?1h=[?1h=[39;49m[?25l[39;49m(B[m[H[2J[29;55H(B[0;7m[ Reading File ][3d(B[m[29;54H(B[0;7m[ Read 59 lines[3d(B[m[?12l[?25h[H[39;49m(B[0;7m  GNU nano 2.5.3                             File: both.ls                                                                  [3;1H(B[mcoll.contacts = new Meteor.Collection \contacts[4dcoll.contacts.allow do[5;5Hinsert: -> true[6;5Hupdate: -> true[7dschema.contacts = new SimpleSchema do[8;5Hname: type: String, label: 'Full Name'[9;5Haddress: type: String, autoform: afFormGroup: class: 'col m6'[10;5Hmobile: type: Number, autoform: afFormGroup: class: 'col m6'[11;5Hmarital:[12;9Htype: Number[13;9Hoptional: true[14;9Hautoform:[15;13Htype: \radio[16;13Hoptions: [[17;17Hvalue: 1, label: \Single[18;13H,[19;17Hvalue: 2, label: \Engaged[20;13H,[21;17Hvalue: 3, label: \Married[22;13H][23;5Hwork:[24dtype: String[25;9Hoptional: true[26;9HallowedValues: <[ business government ]>[27;9Hautoform: type: \select[28;5Hdate:[3d[29;1H[?1049l[?1l>[?1049h[1;44r[?12l[?25h[39;49m(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 2.5.3                             File: both.ls                                                                  [3d(B[mcoll.contacts = new Meteor.Collection \contacts[4dcoll.contacts.allow do[5;5Hinsert: -> true[6;5Hupdate: -> true[7dschema.contacts = new SimpleSchema do[8;5Hname: type: String, label: 'Full Name'[9;5Haddress: type: String, autoform: afFormGroup: class: 'col m6'[10;5Hmobile: type: Number, autoform: afFormGroup: class: 'col m6'[11;5Hmarital:[12;9Htype: Number[13;9Hoptional: true[14;9Hautoform:[15;13Htype: \radio[16;13Hoptions: [[17;17Hvalue: 1, label: \Single[18;13H,[19;17Hvalue: 2, label: \Engaged[20;13H,[21;17Hvalue: 3, label: \Married[22;13H][23;5Hwork:[24dtype: String[25;9Hoptional: true[26;9HallowedValues: <[ business government ]>[27;9Hautoform: type: \select[28;5Hdate:[29;54H(B[0;7m[ Read 59 lines ][3d(B[m[?1h=[?1h=[?1h=[H[2J(B[0;7m  GNU nano 2.5.3                             File: both.ls                                                                  [3d(B[mcoll.contacts = new Meteor.Collection \contacts[4dcoll.contacts.allow do[5;5Hinsert: -> true[6;5Hupdate: -> true[7dschema.contacts = new SimpleSchema do[8;5Hname: type: String, label: 'Full Name'[9;5Haddress: type: String, autoform: afFormGroup: class: 'col m6'[10;5Hmobile: type: Number, autoform: afFormGroup: class: 'col m6'[11;5Hmarital:[12;9Htype: Number[13;9Hoptional: true[14;9Hautoform:[15;13Htype: \radio[16;13Hoptions: [[17;17Hvalue: 1, label: \Single[18;13H,[19;17Hvalue: 2, label: \Engaged[20;13H,[21;17Hvalue: 3, label: \Married[22;13H][23;5Hwork:[24dtype: String[25;9Hoptional: true[26;9HallowedValues: <[ business government ]>[27;9Hautoform: type: \select[28;5Hdate:[29;54H(B[0;7m[ Read 59 lines ][3d(B[m[1;46H(B[0;7m                File: both.ls[1;125H                                              [29;9H(B[mtype: Date[K[30;9Hlabel: 'Date of birth'[31;9HautoValue: (name, allFields) -> new Date![32;5Hhobbies:[33;9Htype: Array[34;9Hautoform: type: \checkbox, options: [[35;13Hvalue: 1, label: \coding[36;9H,[37;13Hvalue: 2, label: \friends[38;9H,[39;13Hvalue: 3, label: \praying[40;9H][41;5H'hobbies.$': type: String[42;5Hmood:[43dtype: Number[3d[44d(B[0;7mSearch:                                                                                                                                                                  [?7l [?7h[44;9H(B[m(B[0;7mb(B[m(B[0;7mo(B[m(B[0;7mo(B[m(B[0;7ml(B[m[?25l[44;76H[1K (B[0;7m[ Search Wrapped ](B[m[K[3d[44;76H(B[0;7m[ "bool" not found ][3d(B[m[?12l[?25h[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d[22d[23d[A[A[22d[22;14H[17;43r[43;1H[5S[1;44r[3;1H    mood:[K[4d[1K type: Number[K[5;5H    autoform: type: \range[6;5Hbiography:[K[7;8H[1K type: String[K[8;5H    autoform: type: \textarea[K[9;5Hfamily: type: Object[K[10;5H'family.father': type: String, label: "Father's Name"[K[11;5H'family.mother': type: String, label: "Mother's Name"[12d[K[13;5Hsiblings: type: Array[14;5H'siblings.$': type: String, label: 'Sibling name'[15d[K[16;5HfirstLevel: type: Object[17;5H'firstLevel.secondLevel': type: Object[18;5H'firstLevel.secondLevel.thirdLevel': type: String[19;5H'firstLevel.secondLevel.otherLevel':[20;9Htype: String[K[21;27Hlove hate ]>[K[23d[K[24d[K[25d[K[26d[K[27d[K[28d[K[29d[K[30d[K[31d[K[32d[K[33d[K[34d[K[35d[K[36d[K[37d[K[38d[K[22;14H[44d[J[23d[1;161H(B[0;7mModified[23;5H(B[mdeceasedd : type: Boolean[44d(B[0;7mFile Name to Write: both.ls                                                                                                                                              [?7l [?7h[44;28H(B[m[?25l[44;76H[39;49m(B[m[1K (B[0;7m[ Wrote 60 lines ](B[m[K[23;28H[?12l[?25h[1;161H(B[0;7m        [23;28H(B[m[1;161H(B[0;7mModified[23d(B[m[K[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[2;43r[2;1HM[1;44r[3;5H'hobbies.$': type: String[2;43r[2;1HM[1;44r[3;9H][2;43r[2;1HM[1;44r[3;13Hvalue: 3, label: \praying[2;43r[2;1HM[1;44r[3;9H,[A[L[3;13Hvalue: 2, label: \friends[A[L[3;9H,[A[L[3;13Hvalue: 1, label: \coding[A[L[3;9Hautoform: type: \checkbox, options: [[A[L[3;9Htype: Array[A[L[3;5Hhobbies:[A[L[3;9HautoValue: (name, allFields) -> new Date![A[L[3;9Hlabel: 'Date of birth'[A[L[3;9Htype: Date[A[L[3;5Hdate:[A[L[3;9Hautoform: type: \select[A[L[3;9HallowedValues: <[ business government ]>[A[L[3;9Hoptional: true[A[L[3;9Htype: String[A[L[3;5Hwork:[A[L[3;13H][A[L[3;17Hvalue: 3, label: \Married[2;43r[2;1HM[1;44r[3;13H,[2;43r[2;1HM[1;44r[3;17Hvalue: 2, label: \Engaged[2;43r[2;1HM[1;44r[3;13H,[2;43r[2;1HM[1;44r[3;17Hvalue: 1, label: \Single[2;43r[2;1HM[1;44r[3;13Hoptions: [[2;43r[2;1HM[1;44r[3;13Htype: \radio[2;43r[2;1HM[1;44r[3;9Hautoform:[A[L[3;9Hoptional: true[2;43r[2;1HM[1;44r[3;9Htype: Number[2;43r[2;1HM[1;44r[3;5Hmarital:[A[L[3;5Hmobile: type: Number, autoform: afFormGroup: class: 'col m6'[2;43r[2;1HM[1;44r[3;5Haddress: type: String, autoform: afFormGroup: class: 'col m6'[2;43r[2;1HM[1;44r[3;5Hname: type: String, label: 'Full Name'[2;43r[2;1HM[1;44r[3;1Hschema.contacts = new SimpleSchema do[2;43r[2;1HM[1;44r[3;5Hupdate: -> true[2;43r[2;1HM[1;44r[3;5Hinsert: -> true[2;43r[2;1HM[1;44r[3;1Hcoll.contacts.allow do[2;43r[2;1HM[1;44r[3;1Hcoll.contacts = new Meteor.Collection \contacts[4d[5d[6d[7d[8d[9d[10d[A[A7[8;43r8M[1;44r[8;5Hdeceased: type: Boolean[9d[44d(B[0;7mFile Name to Write: both.ls                                                                                                                                              [?7l [?7h[44;28H(B[m[?25l[44;76H[39;49m(B[m[1K (B[0;7m[ Wrote 60 lines ](B[m[K[9d[?12l[?25h[1;161H(B[0;7m        [9d(B[m[44d[J[170G[44;1H[?1049l[?1l>]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ nano folder/funcs.ls 
[?1049h[1;44r(B[m[4l[?7h[?1h=[?1h=[?1h=[39;49m[?25l[39;49m(B[m[H[2J[44;78H(B[0;7m[ Reading File ][3d(B[m[44;77H(B[0;7m[ Read 217 lines ][3d(B[m[?12l[?25h[H[39;49m(B[0;7m  GNU nano 2.5.3                                          File: folder/funcs.ls                                                                                           [3;1H(B[m@_ = lodash[4d@coll = {}; @schema = {}; @state = {};[6dif Meteor.isClient[8;5H@m = require \mithril[10;5H@autoForm = (opts) ->[11;9Hscope = opts.scope and new SimpleSchema _.reduce opts.schema._schema,[12;13H(res, val, key) -> if (new RegExp "^#{opts.scope}")test(key)?[13;17H_.assign res, "#key": val[14;9H, {}[15;9HusedSchema = scope or opts.schema[16;9HtheSchema = (name) -> usedSchema._schema[name][17;9HomitFields = if opts.omitFields[18;13H_.pull (_.values usedSchema._firstLevelSchemaKeys), ...opts.omitFields[19;9HusedFields = omitFields or opts.fields or usedSchema._firstLevelSchemaKeys[20;9HoptionList = (name) ->[21;13HtheSchema(name)allowedValues?map (i) ->[22;17Hvalue: i, label: _.startCase i[23;13Hor theSchema(name)autoform?options[24;9Hstate.arrLen ?= {}; state.form ?= {}; state.temp ?= {}[25;9Hstate.form[opts.id] ?= {}; state.temp[opts.id] ?= [][26;9HstateTempGet = (field) -> if state.temp[opts.id][27;13H_.findLast state.temp[opts.id], (i) -> i.name is field[29;9Hattr =[30dform:[31donchange: ({target}) ->[32;21Hunless theSchema(target.name)?autoform?type in <[radio checkbox select]>[33;25Hstate.form[opts.id][target.name] = target.value[34;17Honsubmit: (e) ->[35;21He.preventDefault![36;21Htemp = state.temp[opts.id]map (i) -> "#{i.name}": i.value[37;21Hfiltered = _.filter e.target, (i) ->[38;25Ha = -> i.value isnt \on and i.name[39;25Hb = -> theSchema(i)?autoform?type in <[radio checkbox select]>[40;25Ha! and not b![41;21Hobj = _.merge ... temp.concat _.map filtered, ({name, value}) -> if name[42;25H_.reduceRight name.split(\.), ((res, inc) -> "#inc": res), do ->[43;29Hif value[3d[3;24H[1K _.reduceRight name.split(\.), ((res, inc) -> "#inc": res), do ->[4;28H[1K if value[K[5;33Hnormed = name.replace /(\d+)/g, \$[6;32H[1K switch theSchema(normed)type[7;37Hwhen String then value[8;36H[1K when Number then +value[9;37Hwhen Date then new Date value[10;28H[1K else if theSchema(normed)?autoValue?[11;32H[1K theSchema(normed)?autoValue name, temp.concat filtered[12;20H[1K makeArr = (name, value) ->[K[13;24H[1K if value is Object value then "#name":[14;28H[1K if value.0[15;32H[1K Object.keys value .map (key) ->[16;36H[1K makeArr key, value[key][17;28H[1K else if value.getMonth then value[18;28H[1K else Object.assign {},[K[19;32H[1K ... Object.keys value .map (key) ->[K[20;36H[1K makeArr key, value[key][21;24H[1K else[K[22d[1K if +name >= 0 then value[23;28H[1K else "#name": value[24;20H[1K obj = makeArr \obj, obj .obj[K[25;20H[1K for key, val of obj[K[26;24H[1K if key.split(\.)length > 1[K[27;28H[1K delete obj[key][K[28;21HdataTest = do ->[29;24H[1K a = usedSchema.newContext![30;24H[1K a.validate obj[31;24H[1K a._invalidKeys.map (i) ->[32;28H[1K Materialize.toast "#{i.name} - #{i.type}", 8000ms, \orange[K[33;25Hcheck obj, usedSchema[K[34;17H    formTypes = (doc) ->[35;21H    insert: -> opts.collection.insert (doc or obj)[36;21H    update: -> opts.collection.update do[K[37;28H[1K {_id: opts.doc._id}, {$set: (doc or obj)}[38;25Hmethod: -> Meteor.call opts.meteormethod, (doc or obj)[39;25H'update-pushArray': -> opts.collection.update {_id: opts.doc._id},[40;25H    $push: "#{opts.scope}": $each: _.values obj[opts.scope][41;21Hif opts.hooks?before[K[42;25Hopts.hooks.before obj, (moded) -> formTypes(moded)[opts.type]![K[43;21Helse formTypes![opts.type]![3d[2;43r[2;1HM[1;44r[3;21Hobj = _.merge ... temp.concat _.map filtered, ({name, value}) -> if name[2;43r[2;1HM[1;44r[3;25Ha! and not b![2;43r[2;1HM[1;44r[3;25Hb = -> theSchema(i)?autoform?type in <[radio checkbox select]>[2;43r[2;1HM[1;44r[3;25Ha = -> i.value isnt \on and i.name[2;43r[2;1HM[1;44r[3;21Hfiltered = _.filter e.target, (i) ->[2;43r[2;1HM[1;44r[3;21Htemp = state.temp[opts.id]map (i) -> "#{i.name}": i.value[2;43r[2;1HM[1;44r[3;21He.preventDefault![2;43r[2;1HM[1;44r[3;17Honsubmit: (e) ->[2;43r[2;1HM[1;44r[3;25Hstate.form[opts.id][target.name] = target.value[2;43r[2;1HM[1;44r[3;21Hunless theSchema(target.name)?autoform?type in <[radio checkbox select]>[2;43r[2;1HM[1;44r[3;17Honchange: ({target}) ->[2;43r[2;1HM[1;44r[3;13Hform:[2;43r[2;1HM[1;44r[3;9Hattr =[2;43r[2;1HM[1;44r[3;1H[4d[5d[A[5d[6d[7d[8d[A[A[A[44d[J[6d[7d[A[7d[8d[9d[A[A[8d[9d[10d[11d[12d[13d[A[A[A[A[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d[22d[23d[24d[25d[A[A[24d[25d[A[A[24d[3;21HdataTest = do ->[4;24H[1K a = usedSchema.newContext![5;24H[1K a.validate obj[6;24H[1K a._invalidKeys.map (i) ->[7;28H[1K Materialize.toast "#{i.name} - #{i.type}", 8000ms, \orange[K[8;25Hcheck obj, usedSchema[K[9;17H    formTypes = (doc) ->[10;21H    insert: -> opts.collection.insert (doc or obj)[11;21H    update: -> opts.collection.update do[K[12;28H[1K {_id: opts.doc._id}, {$set: (doc or obj)}[13;25Hmethod: -> Meteor.call opts.meteormethod, (doc or obj)[14;25H'update-pushArray': -> opts.collection.update {_id: opts.doc._id},[15;25H    $push: "#{opts.scope}": $each: _.values obj[opts.scope][16;21Hif opts.hooks?before[K[17;25Hopts.hooks.before obj, (moded) -> formTypes(moded)[opts.type]![K[18;21Helse formTypes![opts.type]![19;21Hopts.hooks?after? obj[K[20d[K[21;13Hradio: (name, value) ->[K[22;17Htype: \radio, name: name, id: "#name#value"[23;17Hchecked: value is (stateTempGet(name)?value or opts.doc?[name])[24;17Honcreate: ({dom}) -> $ dom .on \change, ->[K[25;21Hstate.temp[opts.id]push {name, value}[K[26d[K[27;13Hselect: (name) ->[K[28;17Hname: name[K[29;17Hvalue: stateTempGet(name)?value or opts.doc?[name][30;17Honcreate: ({dom}) ->[K[31;21H$ dom .material_select![K[32;21H$ dom .on \change -> state.temp[opts.id]push do[33;25Hname: name, value: $ dom .val![K[34d[K[35;13Hcheckbox: (name) ->[36;17Honcreate: ({dom}) -> $ dom .on \change ->[37;21Hstate.temp[opts.id]push name: name, value:[38;21H    _.map $("input:checked[name='#name']"), (i) ->[39;28H[1K i.attributes.data.nodeValue[40d[K[41;13HarrLen: (name, type) -> onclick: ->[42;17Hstate.arrLen[name] ?= 0[43;17Hnum = inc: 1, dec: -1[K[24d[3;17Hstate.arrLen[name] ?= 0[4;17Hnum = inc: 1, dec: -1[K[5;17Hstate.arrLen[name] += num[type][6d[K[7;9Hview: -> m \form, attr.form,[K[8;13Hm \.row, usedFields.map (i) ->[K[9d[K[10;17HinputTypes = (name, schema) ->[K[11d[K[12;21Htextarea: -> m \.input-field,[K[13;26H \textarea.materialize-textarea,[K[14;25H    name: name, id: name, value:[K[15;29H    state.form[opts.id][name] or opts.doc?[name][K[16;21H    m \label, for: name, _.startCase name[17d[K[18;21Hrange: -> m \.input-field,[K[19;21H    m \label, for: name, _.startCase name[20;25Hm \.row[21;24H[1K m \input,[K[22;28H[1K type: \rang[47Gname, name: name,[23;28H[1K value: state.form[opts.id][name] or opts.doc?[name]?toString![24d[K[25;21Hcheckbox: -> m \div, attr.checkbox(name),[26;25Hm \h6.grey-text, _.startCase name[27;24H[1K optionList(name)map (j) -> m \.col,[28;28H[1K m \input,[29;32H[1K type: \checkbox, name: name,[K[30;32H[1K id: "#name#{j.value}", data: j.value[31;32H[1K checked:[K[32;36H[1K if stateTempGet(name)[K[33;40H[1K j.value.toString! in stateTempGet(name)value[34;37Helse if opts.doc?[name][35;40H[1K j.value.toString! in opts.doc[name][36;28H[1K m \label, for: "#name#{j.value}", _.startCase j.label[37;21H    m \.row[K[38d[K[39;21Hselect: -> m \.input-field,[K[40;25Hm \label, _.startCase name[41;24H[1K m \.row[K[42;24H[1K m \select, attr.select(name),[43;28H[1K m \option, value: '', _.startCase 'Select One'[24d[3;24H[1K m \select, attr.select(name),[4;28H[1K m \option, value: '', _.startCase 'Select One'[5;28H[1K optionList(name)map (j) ->[6;33Hm \option, value: j.value, _.startCase j.label[7d[K[8;20H[1K radio: -> m \div,[K[9;25Hm \.row[10;24H[1K m \h6.grey-text, _.startCase name[11;25Hm \.row, optionList(name)map (j) -> m \.col,[12;28H[1K m \input, attr.radio name, j.value[13;25H    m \label, for: "#name#{j.value}", _.startCase j.label[14d[K[15;21Hother: ->[K[16;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[17;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[18;21H    maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[19d[K[20;25Hif defaultType![21;25H    m \.input-field,[22;29H    class: schema.autoform?afFormGroup?class,[23;29H    m \label, for: i, _.startCase (schema?label or name)[K[24;33Hm \.row if defaultType!0 is \date[25;32H[1K m \input,[K[26;36H[1K name: name, id: name,[27;36H[1K type: schema.autoform?type or defaultType!0[28;36H[1K value: do ->[29;40H[1K date = if opts.doc?[i] then if defaultType!0 is \date[30;44H[1K moment opts.doc[i] .format \YYYY-MM-DD[31;40H[1K state.form[opts.id]?[name] or date or opts.doc?[i][32d[K[33;25Helse if schema.type is Object[K[34;29Hfiltered = _.filter maped, (j) ->[35;33Ha = -> _.includes j.name, "#name."[K[36;29H    b = -> name.split(\.)length+1 is j.name.split(\.)length[37;32H[1K a! and b![38;29Hm \.card, m \.card-content,[39;32H[1K m \.card-title, _.startCase name[40;32H[1K filtered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![41d[K[42;25Helse if schema.type is Array[K[43;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[24d[39d[J[3;25Helse if schema.type is Array[K[4;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[5;29Hm \.card, m \.card-content,[6;36H.card-title,[K[7;37Hm \p, _.startCase name[8;36H[1K m \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[9;36H[1K m \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[10;32H[1K filtered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[11;36H[1K iter = "#{_.replace j.name, \$, ''}#num"[12;36H[1K inputTypes(iter, j)[j?autoform?type or \other]![13d[K[14;17HinputTypes(i, theSchema i)[theSchema(i)?autoform?type or \other]![15d[K[16;13Hm \.row,[K[17;17Hm \.col, m \input.btn,[K[18;21Htype: \submit[K[19;21Hvalue: opts?buttonContent[20;21Hclass: opts?buttonClasses[21;17Hm \.col, m \input.btn,[K[22;21Htype: \reset[K[23;21Hvalue: opts?reset?content[K[24;21Hclass: opts?reset?classes[K[25d[K[26;5H@autoTable = (opts) ->[K[27;9Hattr =[K[28drowEvent: (doc) ->[K[29;17Honclick: -> opts.rowEvent.onclick doc[K[30;17Hondblclick: -> opts.rowEvent.ondblclick doc[K[31d[K[32;9Hview: -> m \table,[33;13Hm \thead,[K[34;17Hm \tr, opts.fields.map (i) ->[K[35;21Hm \th, _.startCase i[K[36;13Hm \tbody, opts.collection.find!fetch!map (i) ->[K[37;17Hm \tr, attr.rowEvent(i), opts.fields.map (j) ->[38;21Hm \td, i[j][K[24d[3;25Hm \select, attr.select(name),[4;29Hm \option, value: '', _.startCase 'Select One'[K[5;29HoptionList(name)map (j) ->[K[6;36Hoption, value: j.value, _.startCase j.label[7d[K[8;21Hradio: -> m \div,[K[9;25Hm \.row[K[10;25Hm \h6.grey-text, _.startCase name[K[11;25Hm \.row, optionList(name)map (j) -> m \.col,[K[12;29Hm \input, attr.radio name, j.value[K[13;29Hm \label, for: "#name#{j.value}", _.startCase j.label[14d[K[15;21Hother: ->[16;24H[1K defaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[17;24H[1K defaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[18;21H    maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[19d[K[20;21H    if defaultType![K[21;28H[1K m \.input-field,[22;32H[1K class: schema.autoform?afFormGroup?class,[23;32H[1K m \label, for: i, _.startCase (schema?label or name)[24;32H[1K m \.row if defaultType!0 is \date[25;33Hm \input,[26;36H[1K name: name, id: name,[27;36H[1K type: schema.autoform?type or defaultType!0[28;36H[1K value: do ->[29;40H[1K date = if opts.doc?[i] then if defaultType!0 is \date[30;44H[1K moment opts.doc[i] .format \YYYY-MM-DD[31;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][32d[K[33;24H[1K else if schema.type is Object[34;28H[1K filtered = _.filter maped, (j) ->[35;32H[1K a = -> _.includes j.name, "#name."[36;32H[1K b = -> name.split(\.)length+1 is j.name.split(\.)length[37;32H[1K a! and b![K[38;28H[1K m \.card, m \.card-content,[39;33Hm \.card-title, _.startCase name[40;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![42;25Helse if schema.type is Array[43;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[24d[25d[26d[27d[28d[29d[30d[31d[32d[33d[34d[35d[36d[37d[38d[39d[40d[41d[42d[43d[3d[M[43;29Hm \.card, m \.card-content,[3d[M[43;33Hm \.card-title,[3d[M[43;37Hm \p, _.startCase name[3d[M[43;37Hm \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[2d[M[43;37Hm \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[3d[M[43;33Hfiltered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[3d[M[43;37Hiter = "#{_.replace j.name, \$, ''}#num"[A[3;17HinputTypes = (name, schema) ->[K[4d[K[5;21Htextarea: -> m \.input-field,[K[6;25Hm \textarea.materialize-textarea,[K[7;29Hname: name, id: name, value:[8;32H[1K state.form[opts.id][name] or opts.doc?[name][9;25Hm \label, for: name, _.startCase name[K[10d[K[11;21Hrange: -> m \.input-field,[K[12;25Hm \label, for: name, _.startCase name[13;25Hm \.row[K[14;25Hm \input,[K[15;29Htype: \range, id: name, name: name,[K[16;29Hvalue: state.form[opts.id][name] or opts.doc?[name]?toString![17d[K[18;21Hcheckbox: -> m \div, attr.checkbox(name),[19;25Hm \h6.grey-text, _.startCase name[20;25HoptionList(name)map (j) -> m \.col,[K[21;29Hm \input,[K[22;33Htype: \checkbox, name: name,[K[23;33Hid: "#name#{j.value}", data: j.value[K[24;33Hchecked:[K[25;37Hif stateTempGet(name)[26;40H[1K j.value.toString! in stateTempGet(name)value[27;36H[1K else if opts.doc?[name][K[28;40H[1K j.value.toString! in opts.doc[name][29;29Hm \label, for: "#name#{j.value}", _.startCase j.label[K[30;25Hm \.row[K[31d[K[32;21Hselect: -> m \.input-field,[K[33;25Hm \label, _.startCase name[K[34;25Hm \.row[35;25Hm \select, attr.select(name),[36;29Hm \option, value: '', _.startCase 'Select One'[K[37;29HoptionList(name)map (j) ->[K[38;36Hoption, value: j.value, _.startCase j.label[39d[K[40;21Hradio: -> m \div,[K[41;25Hm \.row[K[42;25Hm \h6.grey-text, _.startCase name[K[43;25Hm \.row, optionList(name)map (j) -> m \.col,[K[A[3;24H[1K m \h6.grey-text, _.startCase name[4;25Hm \.row, optionList(name)map (j) -> m \.col,[5;28H[1K m \input, attr.radio name, j.value[6;25H    m \label, for: "#name#{j.value}", _.startCase j.label[7d[K[8;21Hother: ->[K[9;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[10;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[11;21H    maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[12d[K[13;25Hif defaultType![14;25H    m \.input-field,[15;29H    class: schema.autoform?afFormGroup?class,[16;29H    m \label, for: i, _.startCase (schema?label or name)[K[17;33Hm \.row if defaultType!0 is \date[18;32H[1K m \input,[K[19;36H[1K name: name, id: name,[20;36H[1K type: schema.autoform?type or defaultType!0[21;36H[1K value: do ->[22;40H[1K date = if opts.doc?[i] then if defaultType!0 is \date[23;44H[1K moment opts.doc[i] .format \YYYY-MM-DD[24;40H[1K state.form[opts.id]?[name] or date or opts.doc?[i][25d[K[26;25Helse if schema.type is Object[K[27;29Hfiltered = _.filter maped, (j) ->[28;33Ha = -> _.includes j.name, "#name."[K[29;29H    b = -> name.split(\.)length+1 is j.name.split(\.)length[30;32H[1K a! and b![31;29Hm \.card, m \.card-content,[32;32H[1K m \.card-title, _.startCase name[33;32H[1K filtered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![34d[K[35;25Helse if schema.type is Array[K[36;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[37;29Hm \.card, m \.card-content,[38;36H.card-title,[K[39;37Hm \p, _.startCase name[40;36H[1K m \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[41;36H[1K m \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[42;32H[1K filtered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[43;36H[1K iter = "#{_.replace j.name, \$, ''}#num"[A[43d[J[3;25H    m \.card, m \.card-content,[K[4;32H[1K m \.card-title, _.startCase name[K[5;29H    filtered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![6d[K[7;25Helse if schema.type is Array[8;28H[1K filtered = _.filter maped, (j) -> _.includes j.name, "#name.$"[9;25H    m \.card, m \.card-content,[K[10;32H[1K m \.card-title,[K[11;36H[1K m \p, _.startCase name[K[12;37Hm \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[13;36H[1K m \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[14;29H    filtered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[15;33H    iter = "#{_.replace j.name, \$, ''}#num"[16;33H    inputTypes(iter, j)[j?autoform?type or \other]![K[17d[K[18;17HinputTypes(i, theSchema i)[theSchema(i)?autoform?type or \other]![19d[K[20;13Hm \.row,[K[21;17Hm \.col, m \input.btn,[K[22;21Htype: \submit[K[23;21Hvalue: opts?buttonContent[K[24;21Hclass: opts?buttonClasses[K[25;17Hm \.col, m \input.btn,[26;21Htype: \reset[K[27;21Hvalue: opts?reset?content[K[28;21Hclass: opts?reset?classes[K[29d[K[30;5H@autoTable = (opts) ->[K[31;9Hattr =[K[32drowEvent: (doc) ->[K[33;17Honclick: -> opts.rowEvent.onclick doc[K[34;17Hondblclick: -> opts.rowEvent.ondblclick doc[35d[K[36;9Hview: -> m \table,[K[37;13Hm \thead,[K[38;17Hm \tr, opts.fields.map (i) ->[K[39;21Hm \th, _.startCase i[K[40;13Hm \tbody, opts.collection.find!fetch!map (i) ->[K[41;17Hm \tr, attr.rowEvent(i), opts.fields.map (j) ->[K[42;21Hm \td, i[j][K[43d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[L[3;33Ha! and b![2;43r[2;1HM[1;44r[3;33Hb = -> name.split(\.)length+1 is j.name.split(\.)length[2;43r[2;1HM[1;44r[3;33Ha = -> _.includes j.name, "#name."[2;43r[2;1HM[1;44r[3;29Hfiltered = _.filter maped, (j) ->[2;43r[2;1HM[1;44r[3;25Helse if schema.type is Object[2;43r[2;1HM[1;44r[3;1H[2;43r[2;1HM[1;44r[3;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][2;43r[2;1HM[1;44r[3;45Hmoment opts.doc[i] .format \YYYY-MM-DD[A[L[3;41Hdate = if opts.doc?[i] then if defaultType!0 is \date[2;43r[2;1HM[1;44r[3;37Hvalue: do ->[2;43r[2;1HM[1;44r[3;37Htype: schema.autoform?type or defaultType!0[2;43r[2;1HM[1;44r[3;37Hname: name, id: name,[2;43r[2;1HM[1;44r[3;33Hm \input,[2;43r[2;1HM[1;44r[3;33Hm \.row if defaultType!0 is \date[A[L[3;33Hm \label, for: i, _.startCase (schema?label or name)[2;43r[2;1HM[1;44r[3;33Hclass: schema.autoform?afFormGroup?class,[2;43r[2;1HM[1;44r[3;29Hm \.input-field,[2;43r[2;1HM[1;44r[3;25Hif defaultType![2;43r[2;1HM[1;44r[3;1H[2;43r[2;1HM[1;44r[3;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[2;43r[2;1HM[1;44r[3;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[2;43r[2;1HM[1;44r[3;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[2;43r[2;1HM[1;44r[3;21Hother: ->[2;43r[2;1HM[1;44r[3;1H[A[L[3;29Hm \label, for: "#name#{j.value}", _.startCase j.label[2;43r[2;1HM[1;44r[3;29Hm \input, attr.radio name, j.value[A[L[3;25Hm \.row, optionList(name)map (j) -> m \.col,[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[A[A[A[A[A[A[A[8;101H[44d(B[0;7mSearch:                                                                                                                                                                  [?7l [?7h[44;9H(B[m(B[0;7mb(B[m(B[0;7mo(B[m(B[0;7mo(B[m(B[0;7ml(B[m[?25l[44;76H[1K (B[0;7m[ Search Wrapped ](B[m[K[8;101H[?12l[?25h[8;82H[44d(B[0;7mSearch [bool]:                                                                                                                                                           [?7l [?7h[44;16H(B[m[?25l[44;76H[1K (B[0;7m[ Search Wrapped ](B[m[K[8;82H[44;70H(B[0;7m[ This is the only occurrence ][8;82H(B[m[?12l[?25h[44d(B[0;7mSearch [bool]:                                                                                                                                                           [?7l [?7h[44;16H(B[m[?25l[44;76H[1K (B[0;7m[ Search Wrapped ](B[m[K[8;82H[44;70H(B[0;7m[ This is the only occurrence ][8;82H(B[m[?12l[?25h[44d(B[0;7mSearch [bool]:                                                                                                                                                           [?7l [?7h[44;16H(B[m(B[0;7mr(B[m(B[0;7ma(B[m(B[0;7md(B[m(B[0;7mi(B[m(B[0;7mo(B[m(B[0;7m:(B[m[?25l[44;76H[1K (B[0;7m[ Search Wrapped ](B[m[K[8;82H[?12l[?25h[3;25Hif key.split(\.)length > 1[K[4;29Hdelete obj[key][K[5;21HdataTest = do ->[K[6;25Ha = usedSchema.newContext![7;21H    a.validate obj[8;25Ha._invalidKeys.map (i) ->[K[9;25H    Materialize.toast "#{i.name} - #{i.type}", 8000ms, \orange[K[10;25Hcheck obj, usedSchema[K[11;21HformTypes = (doc) ->[12;26Hnsert: -> opts.collection.insert (doc or obj)[13;25Hupdate: -> opts.collection.update do[14;29H{_id: opts.doc._id}, {$set: (doc or obj)}[K[15;25Hmethod: -> Meteor.call opts.meteormethod, (doc or obj)[K[16;25H'update-pushArray': -> opts.collection.update {_id: opts.doc._id},[17;29H$push: "#{opts.scope}": $each: _.values obj[opts.scope][18;21Hif opts.hooks?before[K[19;25Hopts.hooks.before obj, (moded) -> formTypes(moded)[opts.type]![20;21Helse formTypes![opts.type]![K[21;21Hopts.hooks?after? obj[K[22d[K[23;13Hradio: (name, value) ->[K[24;17Htype: \radio, name: name, id: "#name#value"[25;17Hchecked: value is (stateTempGet(name)?value or opts.doc?[name])[26;17Honcreate: ({dom}) -> $ dom .on \change, ->[K[27;21Hstate.temp[opts.id]push {name, value}[K[28d[K[29;13Hselect: (name) ->[K[30;17Hname: name[K[31;17Hvalue: stateTempGet(name)?value or opts.doc?[name][32;17Honcreate: ({dom}) ->[K[33;21H$ dom .material_select![34;21H$ dom .on \change -> state.temp[opts.id]push do[35;25Hname: name, value: $ dom .val![K[36d[K[37;13Hcheckbox: (name) ->[K[38;17Honcreate: ({dom}) -> $ dom .on \change ->[K[39;21Hstate.temp[opts.id]push name: name, value:[K[40;25H_.map $("input:checked[name='#name']"), (i) ->[K[41;29Hi.attributes.data.nodeValue[K[42d[K[43;13HarrLen: (name, type) -> onclick: ->[K[23;13H[24d[25d[26d[27d[28d[29;13H[30d[31d[32d[33d[34d[35d[36d[37;13H[38d[39d[40d[41d[42d[43;13H7[3;43r8
[1;44r[43;17Hstate.arrLen[name] ?= 0[43;13H7[3;43r8
[1;44r[43;17Hnum = inc: 1, dec: -1[43;13H7[3;43r8
[1;44r[43;17Hstate.arrLen[name] += num[type][43;13H7[3;43r8
[1;44r[43;1H7[3;43r8
[1;44r[43;9Hview: -> m \form, attr.form,[43;13H[3d[M[43;13Hm \.row, usedFields.map (i) ->[K[43;13H[3d[M[43d[3d[M[43;17HinputTypes = (name, schema) ->[43;13H[3d[M[43d[3d[M[43;21Htextarea: -> m \.input-field,[43;13H[3d[M[43;25Hm \textarea.materialize-textarea,[43;13H[3d[M[43;29Hname: name, id: name, value:[43;13H[3d[M[43;33Hstate.form[opts.id][name] or opts.doc?[name][43;13H[3d[M[43;25Hm \label, for: name, _.startCase name[43;13H[3d[M[43d[3d[M[43;21Hrange: -> m \.input-field,[43;13H[3d[M[43;25Hm \label, for: name, _.startCase name[43;13H[3d[M[43;25Hm \.row[43;13H[3d[M[43;25Hm \input,[43;13H[2d[M[43;29Htype: \range, id: name, name: name,[43;13H[3d[M[43;29Hvalue: state.form[opts.id][name] or opts.doc?[name]?toString![43;13H[3d[M[43d[3d[M[43;21Hcheckbox: -> m \div, attr.checkbox(name),[43;13H[3d[M[43;25Hm \h6.grey-text, _.startCase name[43;13H[3d[M[43;25HoptionList(name)map (j) -> m \.col,[43;13H[2d[M[43;29Hm \input,[43;13H[3d[M[43;33Htype: \checkbox, name: name,[43;13H[3d[M[43;33Hid: "#name#{j.value}", data: j.value[43;13H[3d[M[43;33Hchecked:[43;13H[3d[M[43;37Hif stateTempGet(name)[43;13H[3d[M[43;41Hj.value.toString! in stateTempGet(name)value[43;13H[3d[M[43;37Helse if opts.doc?[name][43;13H[3d[M[43;41Hj.value.toString! in opts.doc[name][43;13H[2d[M[43;29Hm \label, for: "#name#{j.value}", _.startCase j.label[43;13H[3d[M[43;25Hm \.row[43;13H[3d[M[43d[3d[M[43;21Hselect: -> m \.input-field,[43;13H[3d[M[43;25Hm \label, _.startCase name[43;13H[3d[M[43;25Hm \.row[43;13H[2d[M[43;25Hm \select, attr.select(name),[43;13H[3d[M[43;29Hm \option, value: '', _.startCase 'Select One'[43;13H[3d[M[43;29HoptionList(name)map (j) ->[43;13H[3d[M[43;33Hm \option, value: j.value, _.startCase j.label[43;13H[3d[M[43d[2d[M[43;21Hradio: -> m \div,[43;13H[3d[M[43;25Hm \.row[43;13H[3d[M[43;25Hm \h6.grey-text, _.startCase name[43;13H[2d[M[43;25Hm \.row, optionList(name)map (j) -> m \.col,[43;13H[3d[M[43;29Hm \input, attr.radio name, j.value[43;13H[2d[M[43;29Hm \label, for: "#name#{j.value}", _.startCase j.label[43;13H[3d[M[43d[3d[M[43;21Hother: ->[43;13H[3d[M[43;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[43;13H[3d[M[43;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[43;13H[3d[M[43;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[43;13H[2d[M[43d[3d[M[43;25Hif defaultType![43;13H[3d[M[43;29Hm \.input-field,[43;13H[3d[M[43;33Hclass: schema.autoform?afFormGroup?class,[43;13H[3d[M[43;33Hm \label, for: i, _.startCase (schema?label or name)[43;13H[3d[M[43;33Hm \.row if defaultType!0 is \date[43;13H[3d[M[43;33Hm \input,[43;13H[2d[M[43;37Hname: name, id: name,[43;13H[3d[M[43;37Htype: schema.autoform?type or defaultType!0[43;13H[3d[M[43;37Hvalue: do ->[43;13H[3d[M[43;41Hdate = if opts.doc?[i] then if defaultType!0 is \date[43;13H[3d[M[43;45Hmoment opts.doc[i] .format \YYYY-MM-DD[43;13H[3d[M[43;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][43;13H[3d[M[43d[3d[M[43;25Helse if schema.type is Object[43;13H[3d[M[43;29Hfiltered = _.filter maped, (j) ->[43;13H[3d[M[43;33Ha = -> _.includes j.name, "#name."[43;13H[3d[M[43;33Hb = -> name.split(\.)length+1 is j.name.split(\.)length[43;13H[3d[M[43;33Ha! and b![43;13H[3d[M[43;29Hm \.card, m \.card-content,[43;13H[3d[M[43;33Hm \.card-title, _.startCase name[43;13H[2d[M[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![43;13H[3d[M[43d[3d[M[43;25Helse if schema.type is Array[43;13H[3d[M[43;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[43;13H[3d[M[43;29Hm \.card, m \.card-content,[43;13H[3d[M[43;33Hm \.card-title,[43;13H[3d[M[43;37Hm \p, _.startCase name[43;13H[3d[M[43;37Hm \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[43;13H[2d[M[43;37Hm \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[43;13H[3d[M[43;33Hfiltered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[43;13H[3d[M[43;37Hiter = "#{_.replace j.name, \$, ''}#num"[43;13H[3d[M[43;37HinputTypes(iter, j)[j?autoform?type or \other]![43;13H[3d[M[43d[3d[M[43;17HinputTypes(i, theSchema i)[theSchema(i)?autoform?type or \other]![43;13H[3d[M[43d[2d[M[43;13Hm \.row,[43;13H[3d[M[43;17Hm \.col, m \input.btn,[43;13H[3d[M[43;21Htype: \submit[43;13H[3d[M[43;21Hvalue: opts?buttonContent[43;13H[3d[M[43;21Hclass: opts?buttonClasses[43;13H[2d[M[43;17Hm \.col, m \input.btn,[43;13H[3d[M[43;21Htype: \reset[43;13H[3d[M[43;21Hvalue: opts?reset?content[43;13H[3d[M[43;21Hclass: opts?reset?classes[43;13H[3d[M[43d[42;13H[A[A[A[A[A[A[A[A[A[32;13H[A[A[A[A[A[A[A[A[A[A[A[22d[23d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[L[3;33Hm \label, for: i, _.startCase (schema?label or name)[2;43r[2;1HM[1;44r[3;33Hclass: schema.autoform?afFormGroup?class,[2;43r[2;1HM[1;44r[3;29Hm \.input-field,[2;43r[2;1HM[1;44r[3;25Hif defaultType![2;43r[2;1HM[1;44r[3;1H[2;43r[2;1HM[1;44r[3;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[2;43r[2;1HM[1;44r[3;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[2;43r[2;1HM[1;44r[3;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[2;43r[2;1HM[1;44r[3;21Hother: ->[3;32H[1K state.form[opts.id][name] or opts.doc?[name][4;25Hm \label, for: name, _.startCase name[K[5d[K[6;21Hrange: -> m \.input-field,[K[7;25Hm \label, for: name, _.startCase name[8;25Hm \.row[K[9;25Hm \input,[K[10;29Htype: \range, id: name, name: name,[K[11;29Hvalue: state.form[opts.id][name] or opts.doc?[name]?toString![12d[K[13;21Hcheckbox: -> m \div, attr.checkbox(name),[14;25Hm \h6.grey-text, _.startCase name[15;25HoptionList(name)map (j) -> m \.col,[K[16;29Hm \input,[K[17;33Htype: \checkbox, name: name,[K[18;33Hid: "#name#{j.value}", data: j.value[K[19;33Hchecked:[K[20;37Hif stateTempGet(name)[21;40H[1K j.value.toString! in stateTempGet(name)value[22;36H[1K else if opts.doc?[name][K[23;40H[1K j.value.toString! in opts.doc[name][24;29Hm \label, for: "#name#{j.value}", _.startCase j.label[K[25;25Hm \.row[K[26d[K[27;21Hselect: -> m \.input-field,[K[28;25Hm \label, _.startCase name[K[29;25Hm \.row[30;25Hm \select, attr.select(name),[31;29Hm \option, value: '', _.startCase 'Select One'[K[32;29HoptionList(name)map (j) ->[K[33;36Hoption, value: j.value, _.startCase j.label[34d[K[35;21Hradio: -> m \div,[K[36;25Hm \.row[K[37;25Hm \h6.grey-text, _.startCase name[K[38;25Hm \.row, optionList(name)map (j) -> m \.col,[K[39;29Hm \input, attr.radio name, j.value[K[40;29Hm \label, for: "#name#{j.value}", _.startCase j.label[41d[K[42;21Hother: ->[43;24H[1K defaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[3d[2;43r[2;1HM[1;44r[3;29Hname: name, id: name, value:[2;43r[2;1HM[1;44r[3;25Hm \textarea.materialize-textarea,[A[L[3;21Htextarea: -> m \.input-field,[2;43r[2;1HM[1;44r[3;1H[2;43r[2;1HM[1;44r[3;17HinputTypes = (name, schema) ->[2;43r[2;1HM[1;44r[3;1H[2;43r[2;1HM[1;44r[3;13Hm \.row, usedFields.map (i) ->[2;43r[2;1HM[1;44r[3;9Hview: -> m \form, attr.form,[2;43r[2;1HM[1;44r[3;1H[A[L[3;17Hstate.arrLen[name] += num[type][2;43r[2;1HM[1;44r[3;17Hnum = inc: 1, dec: -1[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d[22d[23d[24d[25d[26d[27d[28d[29d[30d[31d[32d[33d[34d[35d[36d[37d[38d[39d[40d[41d[42d[43d[3d[M[43;33Hm \option, value: j.value, _.startCase j.label[3d[M[43d[2d[M[43;21Hradio: -> m \div,[3d[M[43;25Hm \.row[3d[M[43;25Hm \h6.grey-text, _.startCase name[2d[M[43;25Hm \.row, optionList(name)map (j) -> m \.col,[3d[M[43;29Hm \input, attr.radio name, j.value[2d[M[43;29Hm \label, for: "#name#{j.value}", _.startCase j.label[3d[M[43d[3d[M[43;21Hother: ->[3d[M[43;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[3d[M[43;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[3d[M[43;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[2d[M[43d[3d[M[43;25Hif defaultType![3d[M[43;29Hm \.input-field,[3d[M[43;33Hclass: schema.autoform?afFormGroup?class,[3d[M[43;33Hm \label, for: i, _.startCase (schema?label or name)[3d[M[43;33Hm \.row if defaultType!0 is \date[3d[M[43;33Hm \input,[2d[M[43;37Hname: name, id: name,[3d[M[43;37Htype: schema.autoform?type or defaultType!0[3d[M[43;37Hvalue: do ->[3d[M[43;41Hdate = if opts.doc?[i] then if defaultType!0 is \date[3d[M[43;45Hmoment opts.doc[i] .format \YYYY-MM-DD[3d[M[43;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][3d[M[43d[3d[M[43;25Helse if schema.type is Object[A[A[A[A[A[A[A[A[A[A[A[A[3;21H$ dom .on \change -> state.temp[opts.id]push do[4;25Hname: name, value: $ dom .val![K[5d[K[6;13Hcheckbox: (name) ->[K[7;17Honcreate: ({dom}) -> $ dom .on \change ->[K[8;21Hstate.temp[opts.id]push name: name, value:[9;25H_.map $("input:checked[name='#name']"), (i) ->[10;28H[1K i.attributes.data.nodeValue[11d[K[12;13HarrLen: (name, type) -> onclick: ->[13;17Hstate.arrLen[name] ?= 0[K[14;17Hnum = inc: 1, dec: -1[K[15;17Hstate.arrLen[name] += num[type][K[16d[K[17;9Hview: -> m \form, attr.form,[18;13Hm \.row, usedFields.map (i) ->[19d[K[20;17HinputTypes = (name, schema) ->[K[21d[K[22;21Htextarea: -> m \.input-field,[K[23;25Hm \textarea.materialize-textarea,[K[24;29Hname: name, id: name, value:[25;32H[1K state.form[opts.id][name] or opts.doc?[name][26;25Hm \label, for: name, _.startCase name[K[27d[K[28;21Hrange: -> m \.input-field,[K[29;25Hm \label, for: name, _.startCase name[30;25Hm \.row[K[31;25Hm \input,[K[32;29Htype: \range, id: name, name: name,[K[33;29Hvalue: state.form[opts.id][name] or opts.doc?[name]?toString![34d[K[35;21Hcheckbox: -> m \div, attr.checkbox(name),[36;25Hm \h6.grey-text, _.startCase name[37;25HoptionList(name)map (j) -> m \.col,[K[38;29Hm \input,[K[39;33Htype: \checkbox, name: name,[K[40;33Hid: "#name#{j.value}", data: j.value[K[41;33Hchecked:[K[42;37Hif stateTempGet(name)[43;40H[1K j.value.toString! in stateTempGet(name)value[31d[3;28H[1K else Object.assign {},[K[4;32H[1K ... Object.keys value .map (key) ->[5;37HmakeArr key, value[key][6;24H[1K else[K[7d[1K if +name >= 0 then value[K[8;28H[1K else "#name": value[K[9;21Hobj = makeArr \obj, obj .obj[K[10;21Hfor key, val of obj[K[11;25Hif key.split(\.)length > 1[12;28H[1K delete obj[key][K[13;17H    dataTest = do ->[K[14;24H[1K a = usedSchema.newContext![15;24H[1K a.validate obj[K[16;25Ha._invalidKeys.map (i) ->[17;28H[1K Materialize.toast "#{i.name} - #{i.type}", 8000ms, \orange[18;24H[1K check obj, usedSchema[19;21HformTypes = (doc) ->[20;24H[1K insert: -> opts.collection.insert (doc or obj)[21;25Hupdate: -> opts.collection.update do[22;28H[1K {_id: opts.doc._id}, {$set: (doc or obj)}[23;26Hethod: -> Meteor.call opts.meteormethod, (doc or obj)[24;25H'update-pushArray': -> opts.collection.update {_id: opts.doc._id},[25;29H$push: "#{opts.scope}": $each: _.values obj[opts.scope][26;21Hif opts.hooks?before[K[27;25Hopts.hooks.before obj, (moded) -> formTypes(moded)[opts.type]![28;21Helse formTypes![opts.type]![29;21Hopts.hooks?after? obj[K[30d[K[31;13Hradio: (name, value) ->[32;17Htype: \radio, name: nam[47G"#name#value"[K[33;17Hchecked: value is (stateTempGet(name)?value or opts.doc?[name])[K[34;17Honcreate: ({dom}) -> $ dom .on \change, ->[35;21Hstate.temp[opts.id]push {name, value}[K[36d[K[37;13Hselect: (name) ->[K[38;17Hname: name[K[39;17Hvalue: stateTempGet(name)?value or opts.doc?[name][40;17Honcreate: ({dom}) ->[K[41;21H$ dom .material_select![42;21H$ dom .on \change -> state.temp[opts.id]push do[43;25Hname: name, value: $ dom .val![K[31d[32d[33d[3;21H$ dom .on \change -> state.temp[opts.id]push do[4;25Hname: name, value: $ dom .val![K[5d[K[6;13Hcheckbox: (name) ->[7;17Honcreate: ({dom}) -> $ dom .on \change ->[8;21Hstate.temp[opts.id]push name: name, value:[9;21H    _.map $("input:checked[name='#name']"), (i) ->[10;28H[1K i.attributes.data.nodeValue[11d[K[12;13HarrLen: (name, type) -> onclick: ->[13;17Hstate.arrLen[name] ?= 0[14;17Hnum = inc: 1, dec: -1[K[15;17Hstate.arrLen[name] += num[type][16d[K[17;9Hview: -> m \form, attr.form,[K[18;13Hm \.row, usedFields.map (i) ->[K[19d[K[20;17HinputTypes = (name, schema) ->[K[21d[K[22;21Htextarea: -> m \.input-field,[K[23;26H \textarea.materialize-textarea,[K[24;25H    name: name, id: name, value:[K[25;29H    state.form[opts.id][name] or opts.doc?[name][K[26;21H    m \label, for: name, _.startCase name[27d[K[28;21Hrange: -> m \.input-field,[K[29;21H    m \label, for: name, _.startCase name[30;25Hm \.row[31;24H[1K m \input,[K[32;28H[1K type: \rang[47Gname, name: name,[33;28H[1K value: state.form[opts.id][name] or opts.doc?[name]?toString![34d[K[35;21Hcheckbox: -> m \div, attr.checkbox(name),[36;25Hm \h6.grey-text, _.startCase name[37;24H[1K optionList(name)map (j) -> m \.col,[38;28H[1K m \input,[39;32H[1K type: \checkbox, name: name,[K[40;32H[1K id: "#name#{j.value}", data: j.value[41;32H[1K checked:[K[42;36H[1K if stateTempGet(name)[K[43;40H[1K j.value.toString! in stateTempGet(name)value[33d[34d[3;36H[1K if stateTempGet(name)[K[4;40H[1K j.value.toString! in stateTempGet(name)value[5;37Helse if opts.doc?[name][6;40H[1K j.value.toString! in opts.doc[name][7;28H[1K m \label, for: "#name#{j.value}", _.startCase j.label[8;21H    m \.row[K[9d[K[10;21Hselect: -> m \.input-field,[K[11;25Hm \label, _.startCase name[12;24H[1K m \.row[K[13;24H[1K m \select, attr.select(name),[14;28H[1K m \option, value: '', _.startCase 'Select One'[15;28H[1K optionList(name)map (j) ->[16;33Hm \option, value: j.value, _.startCase j.label[17d[K[18;20H[1K radio: -> m \div,[K[19;25Hm \.row[20;24H[1K m \h6.grey-text, _.startCase name[21;25Hm \.row, optionList(name)map (j) -> m \.col,[22;28H[1K m \input, attr.radio name, j.value[23;25H    m \label, for: "#name#{j.value}", _.startCase j.label[24d[K[25;21Hother: ->[K[26;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[27;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[28;21H    maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[29d[K[30;25Hif defaultType![31;25H    m \.input-field,[32;29H    class: schema.autoform?afFormGroup?class,[33;29H    m \label, for: i, _.startCase (schema?label or name)[K[34;33Hm \.row if defaultType!0 is \date[35;32H[1K m \input,[K[36;36H[1K name: name, id: name,[37;36H[1K type: schema.autoform?type or defaultType!0[38;36H[1K value: do ->[39;40H[1K date = if opts.doc?[i] then if defaultType!0 is \date[40;44H[1K moment opts.doc[i] .format \YYYY-MM-DD[41;40H[1K state.form[opts.id]?[name] or date or opts.doc?[i][42d[K[43;25Helse if schema.type is Object[K[34d[3;21H$ dom .on \change -> state.temp[opts.id]push do[4;25Hname: name, value: $ dom .val![K[5d[K[6;13Hcheckbox: (name) ->[K[7;17Honcreate: ({dom}) -> $ dom .on \change ->[K[8;21Hstate.temp[opts.id]push name: name, value:[9;25H_.map $("input:checked[name='#name']"), (i) ->[10;28H[1K i.attributes.data.nodeValue[11d[K[12;13HarrLen: (name, type) -> onclick: ->[13;17Hstate.arrLen[name] ?= 0[K[14;17Hnum = inc: 1, dec: -1[K[15;17Hstate.arrLen[name] += num[type][K[16d[K[17;9Hview: -> m \form, attr.form,[18;13Hm \.row, usedFields.map (i) ->[19d[K[20;17HinputTypes = (name, schema) ->[K[21d[K[22;21Htextarea: -> m \.input-field,[K[23;25Hm \textarea.materialize-textarea,[K[24;29Hname: name, id: name, value:[25;32H[1K state.form[opts.id][name] or opts.doc?[name][26;25Hm \label, for: name, _.startCase name[K[27d[K[28;21Hrange: -> m \.input-field,[K[29;25Hm \label, for: name, _.startCase name[30;25Hm \.row[K[31;25Hm \input,[K[32;29Htype: \range, id: name, name: name,[K[33;29Hvalue: state.form[opts.id][name] or opts.doc?[name]?toString![34d[K[35;21Hcheckbox: -> m \div, attr.checkbox(name),[36;25Hm \h6.grey-text, _.startCase name[37;25HoptionList(name)map (j) -> m \.col,[K[38;29Hm \input,[K[39;33Htype: \checkbox, name: name,[K[40;33Hid: "#name#{j.value}", data: j.value[K[41;33Hchecked:[K[42;37Hif stateTempGet(name)[43;40H[1K j.value.toString! in stateTempGet(name)value[34d[3;36H[1K if stateTempGet(name)[K[4;40H[1K j.value.toString! in stateTempGet(name)value[5;37Helse if opts.doc?[name][6;40H[1K j.value.toString! in opts.doc[name][7;28H[1K m \label, for: "#name#{j.value}", _.startCase j.label[8;21H    m \.row[K[9d[K[10;21Hselect: -> m \.input-field,[K[11;25Hm \label, _.startCase name[12;24H[1K m \.row[K[13;24H[1K m \select, attr.select(name),[14;28H[1K m \option, value: '', _.startCase 'Select One'[15;28H[1K optionList(name)map (j) ->[16;33Hm \option, value: j.value, _.startCase j.label[17d[K[18;20H[1K radio: -> m \div,[K[19;25Hm \.row[20;24H[1K m \h6.grey-text, _.startCase name[21;25Hm \.row, optionList(name)map (j) -> m \.col,[22;28H[1K m \input, attr.radio name, j.value[23;25H    m \label, for: "#name#{j.value}", _.startCase j.label[24d[K[25;21Hother: ->[K[26;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[27;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[28;21H    maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[29d[K[30;25Hif defaultType![31;25H    m \.input-field,[32;29H    class: schema.autoform?afFormGroup?class,[33;29H    m \label, for: i, _.startCase (schema?label or name)[K[34;33Hm \.row if defaultType!0 is \date[35;32H[1K m \input,[K[36;36H[1K name: name, id: name,[37;36H[1K type: schema.autoform?type or defaultType!0[38;36H[1K value: do ->[39;40H[1K date = if opts.doc?[i] then if defaultType!0 is \date[40;44H[1K moment opts.doc[i] .format \YYYY-MM-DD[41;40H[1K state.form[opts.id]?[name] or date or opts.doc?[i][42d[K[43;25Helse if schema.type is Object[K[34d[3d[K[4;25Helse if schema.type is Object[K[5;29Hfiltered = _.filter maped, (j) ->[6;33Ha = -> _.includes j.name, "#name."[K[7;29H    b = -> name.split(\.)length+1 is j.name.split(\.)length[8;32H[1K a! and b![9;29Hm \.card, m \.card-content,[10;32H[1K m \.card-title, _.startCase name[11;32H[1K filtered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![12d[K[13;25Helse if schema.type is Array[K[14;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[15;29Hm \.card, m \.card-content,[16;36H.card-title,[K[17;37Hm \p, _.startCase name[18;36H[1K m \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[19;36H[1K m \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[20;32H[1K filtered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[21;36H[1K iter = "#{_.replace j.name, \$, ''}#num"[22;36H[1K inputTypes(iter, j)[j?autoform?type or \other]![23d[K[24;17HinputTypes(i, theSchema i)[theSchema(i)?autoform?type or \other]![25d[K[26;13Hm \.row,[K[27;17Hm \.col, m \input.btn,[K[28;21Htype: \submit[K[29;21Hvalue: opts?buttonContent[30;21Hclass: opts?buttonClasses[31;17Hm \.col, m \input.btn,[K[32;21Htype: \reset[K[33;21Hvalue: opts?reset?content[K[34;21Hclass: opts?reset?classes[K[35d[K[36;5H@autoTable = (opts) ->[K[37;9Hattr =[K[38drowEvent: (doc) ->[K[39;17Honclick: -> opts.rowEvent.onclick doc[K[40;17Hondblclick: -> opts.rowEvent.ondblclick doc[K[41d[K[42;9Hview: -> m \table,[43;13Hm \thead,[K[34d[3d[6M[38;17Hm \tr, opts.fields.map (i) ->[39;21Hm \th, _.startCase i[40;13Hm \tbody, opts.collection.find!fetch!map (i) ->[41;17Hm \tr, attr.rowEvent(i), opts.fields.map (j) ->[42;21Hm \td, i[j][43d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[L[3;33Ha! and b![2;43r[2;1HM[1;44r[3;33Hb = -> name.split(\.)length+1 is j.name.split(\.)length[2;43r[2;1HM[1;44r[3;33Ha = -> _.includes j.name, "#name."[2;43r[2;1HM[1;44r[3;29Hfiltered = _.filter maped, (j) ->[2;43r[2;1HM[1;44r[3;25Helse if schema.type is Object[2;43r[2;1HM[1;44r[3;1H[2;43r[2;1HM[1;44r[3;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][2;43r[2;1HM[1;44r[3;45Hmoment opts.doc[i] .format \YYYY-MM-DD[A[L[3;41Hdate = if opts.doc?[i] then if defaultType!0 is \date[2;43r[2;1HM[1;44r[3;37Hvalue: do ->[2;43r[2;1HM[1;44r[3;37Htype: schema.autoform?type or defaultType!0[2;43r[2;1HM[1;44r[3;37Hname: name, id: name,[2;43r[2;1HM[1;44r[3;33Hm \input,[2;43r[2;1HM[1;44r[3;33Hm \.row if defaultType!0 is \date[A[L[3;33Hm \label, for: i, _.startCase (schema?label or name)[2;43r[2;1HM[1;44r[3;33Hclass: schema.autoform?afFormGroup?class,[2;43r[2;1HM[1;44r[3;29Hm \.input-field,[2;43r[2;1HM[1;44r[3;25Hif defaultType![2;43r[2;1HM[1;44r[3;1H[2;43r[2;1HM[1;44r[3;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[2;43r[2;1HM[1;44r[3;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[2;43r[2;1HM[1;44r[3;25HdefaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[2;43r[2;1HM[1;44r[3;21Hother: ->[2;43r[2;1HM[1;44r[3;1H[A[L[3;29Hm \label, for: "#name#{j.value}", _.startCase j.label[2;43r[2;1HM[1;44r[3;29Hm \input, attr.radio name, j.value[A[L[3;25Hm \.row, optionList(name)map (j) -> m \.col,[2;43r[2;1HM[1;44r[3;25Hm \h6.grey-text, _.startCase name[2;43r[2;1HM[1;44r[3;25Hm \.row[2;43r[2;1HM[1;44r[3;21Hradio: -> m \div,[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[A[A[12;105H[A[91G[11;82H[1;161H(B[0;7mModified[11;79H(B[m[1P[1P[1P[1P[1Pc: Boolean, date: Date[11;76Hh: Boolean, date: Date[11;77He: Boolean, date: Date[11;78Hc: Boolean, date: Date[11;79Hk: Boolean, date: Date[11;80Hb: Boolean, date: Date[11;81Ho: Boolean, date: Date[11;82Hx: Boolean, date: Date[11;83H[44d(B[0;7mFile Name to Write: folder/funcs.ls                                                                                                                                      [?7l [?7h[44;36H(B[m[?25l[44;75H[39;49m(B[m[1K (B[0;7m[ Wrote 217 lines ](B[m[K[11;83H[?12l[?25h[1;161H(B[0;7m        [11;83H(B[m[12d[13d[14d[15;40H[16;45H[17;74H[18;83H[18;43r[43;1H
[1;44r[1;161H(B[0;7mModified[43;33H(B[mfiltered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[18d[19d[20d[21d[22d[23d[24d[25d[26d[A[25;91H[26d7[26;43r8M[1;44r[26;33Hm \label, for: i, _.startCase (schema?label or name)[27d[44d(B[0;7mFile Name to Write: folder/funcs.ls                                                                                                                                      [?7l [?7h[44;36H(B[m[?25l[44;75H[39;49m(B[m[1K (B[0;7m[ Wrote 217 lines ](B[m[K[27d[?12l[?25h[1;161H(B[0;7m        [27d(B[m[28d[29d[30d[31d[32d[33d[34d[35d[36d[37d[38d[39d[40d[41d[42d[43d7[3;43r8
[1;44r[43;33Hfiltered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->7[3;43r8
[1;44r[43;37Hiter = "#{_.replace j.name, \$, ''}#num"7[3;43r8
[1;44r[43;37HinputTypes(iter, j)[j?autoform?type or \other]!7[3;43r8
[1;44r[43;1H[A[A[A[A[A[44d[J[37d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[3;21Htextarea: -> m \.input-field,[K[4;25Hm \textarea.materialize-textarea,[K[5;29Hname: name, id: name, value:[6;32H[1K state.form[opts.id][name] or opts.doc?[name][7;25Hm \label, for: name, _.startCase name[K[8d[K[9;21Hrange: -> m \.input-field,[K[10;25Hm \label, for: name, _.startCase name[11;25Hm \.row[K[12;25Hm \input,[K[13;29Htype: \range, id: name, name: name,[K[14;29Hvalue: state.form[opts.id][name] or opts.doc?[name]?toString![15d[K[16;21Hcheckbox: -> m \div, attr.checkbox(name),[17;25Hm \h6.grey-text, _.startCase name[K[18;25HoptionList(name)map (j) -> m \.col,[19;29Hm \input,[K[20;33Htype: \checkbox, name: name,[K[21;33Hid: "#name#{j.value}", data: j.value[K[22;33Hchecked:[K[23;37Hif stateTempGet(name)[24;40H[1K j.value.toString! in stateTempGet(name)value[25;36H[1K else if opts.doc?[name][K[26;40H[1K j.value.toString! in opts.doc[name][27;29Hm \label, for: "#name#{j.value}", _.startCase j.label[K[28;25Hm \.row[K[29d[K[30;21Hselect: -> m \.input-field,[K[31;25Hm \label, _.startCase name[K[32;25Hm \.row[33;25Hm \select, attr.select(name),[34;29Hm \option, value: '', _.startCase 'Select One'[K[35;29HoptionList(name)map (j) ->[K[36;36Hoption, value: j.value, _.startCase j.label[37d[K[38;21Hradio: -> m \div,[K[39;25Hm \.row[K[40;25Hm \h6.grey-text, _.startCase name[K[41;25Hm \.row, optionList(name)map (j) -> m \.col,[K[42;29Hm \input, attr.radio name, j.value[K[43;29Hm \label, for: "#name#{j.value}", _.startCase j.label[15d[3;28H[1K {_id: opts.doc._id}, {$set: (doc or obj)}[4;26Hethod: -> Meteor.call opts.meteormethod, (doc or obj)[5;25H'update-pushArray': -> opts.collection.update {_id: opts.doc._id},[6;29H$push: "#{opts.scope}": $each: _.values obj[opts.scope][7;21Hif opts.hooks?before[K[8;25Hopts.hooks.before obj, (moded) -> formTypes(moded)[opts.type]![9;21Helse formTypes![opts.type]![10;21Hopts.hooks?after? obj[K[11d[K[12;13Hradio: (name, value) ->[13;17Htype: \radio, name: nam[47G"#name#value"[K[14;17Hchecked: value is (stateTempGet(name)?value or opts.doc?[name])[K[15;17Honcreate: ({dom}) -> $ dom .on \change, ->[16;21Hstate.temp[opts.id]push {name, value}[K[17d[K[18;13Hselect: (name) ->[K[19;17Hname: name[K[20;17Hvalue: stateTempGet(name)?value or opts.doc?[name][21;17Honcreate: ({dom}) ->[K[22;21H$ dom .material_select![23;21H$ dom .on \change -> state.temp[opts.id]push do[24;25Hname: name, value: $ dom .val![K[25d[K[26;13Hcheckbox: (name) ->[K[27;17Honcreate: ({dom}) -> $ dom .on \change ->[K[28;21Hstate.temp[opts.id]push name: name, value:[29;25H_.map $("input:checked[name='#name']"), (i) ->[30;28H[1K i.attributes.data.nodeValue[31d[K[32;13HarrLen: (name, type) -> onclick: ->[33;17Hstate.arrLen[name] ?= 0[K[34;17Hnum = inc: 1, dec: -1[K[35;17Hstate.arrLen[name] += num[type][K[36d[K[37;9Hview: -> m \form, attr.form,[38;13Hm \.row, usedFields.map (i) ->[39d[K[40;17HinputTypes = (name, schema) ->[K[41d[K[42;21Htextarea: -> m \.input-field,[K[43;25Hm \textarea.materialize-textarea,[K[15d[3;21Hfiltered = _.filter e.target, (i) ->[K[4;25Ha = -> i.value isnt \on and i.name[K[5;25Hb = -> theSchema(i)?autoform?type in <[radio checkbox select]>[K[6;25Ha! and not b![K[7;21Hobj = _.merge ... temp.concat _.map filtered, ({name, value}) -> if name[8;25H_.reduceRight name.split(\.), ((res, inc) -> "#inc": res), do ->[9;28H[1K if value[K[10;32H[1K normed = name.replace /(\d+)/g, \$[11;33Hswitch theSchema(normed)type[12;36H[1K when String then value[13;36H[1K when Number then +value[14;36H[1K when Date then new Date value[K[15;28H[1K else if theSchema(normed)?autoValue?[16;32H[1K theSchema(normed)?autoValue name, temp.concat filtered[17;21HmakeArr = (name, value) ->[18;24H[1K if value is Object value then "#name":[19;28H[1K if value.0[20;32H[1K Object.keys value .map (key) ->[K[21;36H[1K makeArr key, value[key][22;28H[1K else if value.getMonth then value[23;28H[1K else Object.assign {},[K[24;32H[1K ... Object.keys value .map (key) ->[25;37HmakeArr key, value[key][26;24H[1K else[K[27d[1K if +name >= 0 then value[K[28;28H[1K else "#name": value[K[29;21Hobj = makeArr \obj, obj .obj[K[30;21Hfor key, val of obj[K[31;25Hif key.split(\.)length > 1[32;28H[1K delete obj[key][K[33;17H    dataTest = do ->[K[34;24H[1K a = usedSchema.newContext![35;24H[1K a.validate obj[K[36;25Ha._invalidKeys.map (i) ->[37;28H[1K Materialize.toast "#{i.name} - #{i.type}", 8000ms, \orange[38;24H[1K check obj, usedSchema[39;21HformTypes = (doc) ->[40;24H[1K insert: -> opts.collection.insert (doc or obj)[41;25Hupdate: -> opts.collection.update do[42;28H[1K {_id: opts.doc._id}, {$set: (doc or obj)}[43;26Hethod: -> Meteor.call opts.meteormethod, (doc or obj)[15d[3d@_ = lodash[K[4d@coll = {}; @schema = {}; @state = {};[K[5d[K[6dif Meteor.isClient[K[7d[K[8;5H@m = require \mithril[K[9d[K[10;5H@autoForm = (opts) ->[K[11;9Hscope = opts.scope and new SimpleSchema _.reduce opts.schema._schema,[12;13H(res, val, key) -> if (new RegExp "^#{opts.scope}")test(key)?[13;17H_.assign res, "#key": val[K[14;9H, {}[K[15;9HusedSchema = scope or opts.schema[K[16;9HtheSchema = (name) -> usedSchema._schema[name][K[17;9HomitFields = if opts.omitFields[K[18;13H_.pull (_.values usedSchema._firstLevelSchemaKeys), ...opts.omitFields[19;9HusedFields = omitFields or opts.fields or usedSchema._firstLevelSchemaKeys[20;9HoptionList = (name) ->[K[21;13HtheSchema(name)allowedValues?map (i) ->[K[22;17Hvalue: i, label: _.startCase i[K[23;13Hor theSchema(name)autoform?options[K[24;9Hstate.arrLen ?= {}; state.form ?= {}; state.temp ?= {}[K[25;9Hstate.form[opts.id] ?= {}; state.temp[opts.id] ?= [][26;9HstateTempGet = (field) -> if state.temp[opts.id][27;13H_.findLast state.temp[opts.id], (i) -> i.name is field[28d[K[29;9Hattr =[K[30dform:[K[31donchange: ({target}) ->[K[32;21Hunless theSchema(target.name)?autoform?type in <[radio checkbox select]>[33;21H    state.form[opts.id][target.name] = target.value[34;17Honsubmit: (e) ->[K[35;21He.preventDefault![K[36;21Htemp = state.temp[opts.id]map (i) -> "#{i.name}": i.value[37;21Hfiltered = _.filter e.target, (i) ->[K[38;25Ha = -> i.value isnt \on and i.name[39;21H    b = -> theSchema(i)?autoform?type in <[radio checkbox select]>[40;25Ha! and not b![K[41;21Hobj = _.merge ... temp.concat _.map filtered, ({name, value}) -> if name[42;25H_.reduceRight name.split(\.), ((res, inc) -> "#inc": res), do ->[43;25H    if value[K[10d[3d[44d(B[0;7mSearch [radio:]:                                                                                                                                                         [?7l [?7h[44;18H(B[m(B[0;7mc(B[m(B[0;7mh(B[m(B[0;7me(B[m(B[0;7mc(B[m(B[0;7mk(B[m(B[0;7mb(B[m(B[0;7mo(B[m(B[0;7mx(B[m[J[32;76H[44d(B[0;7mSearch [checkbox]:                                                                                                                                                       [?7l [?7h[44;20H(B[m[J[39;70H[44d(B[0;7mSearch [checkbox]:                                                                                                                                                       [?7l [?7h[44;20H(B[m[J[3;28H[1K $push: "#{opts.scope}": $each: _.values obj[opts.scope][4;20H[1K if opts.hooks?before[5;25Hopts.hooks.before obj, (moded) -> formTypes(moded)[opts.type]![6;20H[1K else formTypes![opts.type]![7;21Hopts.hooks?after? obj[8d[K[9;13Hradio: (name, value) ->[10;16H[1K type: \radio, name: name, id: "#name#value"[11;16H[1K checked: value is (stateTempGet(name)?value or opts.doc?[name])[12;13H    oncreate: ({dom}) -> $ dom .on \change, ->[K[13;17H    state.temp[opts.id]push {name, value}[14d[K[15;9H    select: (name) ->[K[16;16H[1K name: name[K[17;16H[1K value: stateTempGet(name)?value or opts.doc?[name][18;13H    oncreate: ({dom}) ->[K[19;20H[1K $ dom .material_select![K[20;20H[1K $ dom .on \change -> state.temp[opts.id]push do[21;24H[1K name: name, value: $ dom .val![22d[K[23;13Hcheckbox: (name) ->[K[24;16H[1K oncreate: ({dom}) -> $ dom .on \change ->[K[25;20H[1K state.temp[opts.id]push name: name, value:[26;24H[1K _.map $("input:checked[name='#name']"), (i) ->[27;28H[1K i.attributes.data.nodeValue[K[29;9H    arrLen: (name, type) -> onclick: ->[30;13H    state.arrLen[name] ?= 0[31;17Hnum = inc: 1, dec: -1[K[32;17Hstate.arrLen[name] += num[type][K[33d[K[34;9Hview: -> m \form, attr.form,[35;13Hm \.row, usedFields.map (i) ->[36d[K[37;17HinputTypes = (name, schema) ->[K[38d[K[39;21Htextarea: -> m \.input-field,[K[40;25Hm \textarea.materialize-textarea,[41;28H[1K name: name, id: name, value:[K[42;32H[1K state.form[opts.id][name] or opts.doc?[name][K[43;25Hm \label, for: name, _.startCase name[23;13H[44d(B[0;7mSearch [checkbox]:                                                                                                                                                       [?7l [?7h[44;20H(B[m(B[0;7mo(B[m(B[0;7mn(B[m(B[0;7mc(B[m(B[0;7mh(B[m(B[0;7ma(B[m(B[0;7mn(B[m(B[0;7mg(B[m(B[0;7me(B[m[?25l[44;76H[1K (B[0;7m[ Search Wrapped ](B[m[K[23;13H[?12l[?25h[3;9Hscope = opts.scope and new SimpleSchema _.reduce opts.schema._schema,[K[4;13H(res, val, key) -> if (new RegExp "^#{opts.scope}")test(key)?[5;17H_.assign res, "#key": val[K[6;9H, {}[K[7;9HusedSchema = scope or opts.schema[8;9HtheSchema = (name) -> usedSchema._schema[name][9;9HomitFields = if opts.omitFields[10;13H_.pull (_.values usedSchema._firstLevelSchemaKeys), ...opts.omitFields[11;9HusedFields = omitFields or opts.fields or usedSchema._firstLevelSchemaKeys[12;9HoptionList = (name) ->[K[13;13HtheSchema(name)allowedValues?map (i) ->[K[14;17Hvalue: i, label: _.startCase i[15;13Hor theSchema(name)autoform?options[16;9Hstate.arrLen ?= {}; state.form ?= {}; state.temp ?= {}[17;9Hstate.form[opts.id] ?= {}; state.temp[opts.id] ?= [][K[18;9HstateTempGet = (field) -> if state.temp[opts.id][19;13H_.findLast state.temp[opts.id], (i) -> i.name is field[20d[K[21;9Hattr =[K[22dform:[23;13H    onchange: ({target}) ->[24;17H    unless theSchema(target.name)?autoform?type in <[radio checkbox select]>[25;21H    state.form[opts.id][target.name] = target.value[26;17Honsubmit: (e) ->[K[27;21He.preventDefault![K[28;21Htemp = state.temp[opts.id]map (i) -> "#{i.name}": i.value[29;20H[1K filtered = _.filter e.target, (i) ->[30;24H[1K a = -> i.value isnt \on and i.name[31;24H[1K b = -> theSchema(i)?autoform?type in <[radio checkbox select]>[32;24H[1K a! and not b![K[33;21Hobj = _.merge ... temp.concat _.map filtered, ({name, value}) -> if name[34;24H[1K _.reduceRight name.split(\.), ((res, inc) -> "#inc": res), do ->[35;28H[1K if value[K[36;33Hnormed = name.replace /(\d+)/g, \$[37;32H[1K switch theSchema(normed)type[38;37Hwhen String then value[39;36H[1K when Number then +value[40;36H[1K when Date then new Date value[41;29Helse if theSchema(normed)?autoValue?[42;33HtheSchema(normed)?autoValue name, temp.concat filtered[43;21HmakeArr = (name, value) ->[K[23;17H[2;43r[2;1H[8T[1;44r[3;1H@_ = lodash[4d@coll = {}; @schema = {}; @state = {};[6dif Meteor.isClient[8;5H@m = require \mithril[10;5H@autoForm = (opts) ->[3d[44d(B[0;7mSearch [onchange]:                                                                                                                                                       [?7l [?7h[44;20H(B[m(B[0;7m.(B[m(B[0;7mo(B[m(B[0;7mn(B[m[C(B[0;7m\(B[m(B[0;7mc(B[m(B[0;7mh(B[m(B[0;7ma(B[m(B[0;7mn(B[m(B[0;7mg(B[m(B[0;7me(B[m[J[3;24H[1K a = usedSchema.newContext![4;24H[1K a.validate obj[5;25Ha._invalidKeys.map (i) ->[6;28H[1K Materialize.toast "#{i.name} - #{i.type}", 8000ms, \orange[7;25Hcheck obj, usedSchema[8;20H[1K formTypes = (doc) ->[9;25Hinsert: -> opts.collection.insert (doc or obj)[10;24H[1K update: -> opts.collection.update do[11;28H[1K {_id: opts.doc._id}, {$set: (doc or obj)}[K[12;24H[1K method: -> Meteor.call opts.meteormethod, (doc or obj)[13;24H[1K 'update-pushArray': -> opts.collection.update {_id: opts.doc._id},[14;28H[1K $push: "#{opts.scope}": $each: _.values obj[opts.scope][15;20H[1K if opts.hooks?before[K[16;24H[1K opts.hooks.before obj, (moded) -> formTypes(moded)[opts.type]![17;20H[1K else formTypes![opts.type]![18;20H[1K opts.hooks?after? obj[K[19d[K[20;9H    radio: (name, value) ->[21;13H    type: \radio, name: name, id: "#name#value"[22;17Hchecked: value is (stateTempGet(name)?value or opts.doc?[name])[23;13H    oncreate: ({dom}) -> $ dom .on \change, ->[24;20H[1K state.temp[opts.id]push {name, value}[K[25d[K[26;9H    select: (name) ->[K[27;13H    name: name[K[28;17Hvalue: stateTempGet(name)?value or opts.doc?[name][29;16H[1K oncreate: ({dom}) ->[30;20H[1K $ dom .material_select![31;17H    $ dom .on \change -> state.temp[opts.id]push do[32;21H    name: name, value: $ dom .val![K[33d[K[34;13Hcheckbox: (name) ->[K[35;17Honcreate: ({dom}) -> $ dom .on \change ->[36;21Hstate.temp[opts.id]push name: name, value:[K[37;21H    _.map $("input:checked[name='#name']"), (i) ->[38;25H    i.attributes.data.nodeValue[K[39d[K[40;13HarrLen: (name, type) -> onclick: ->[41;17Hstate.arrLen[name] ?= 0[K[42;17Hnum = inc: 1, dec: -1[K[43;17Hstate.arrLen[name] += num[type][23;44H[44d(B[0;7mSearch [.on \change]:                                                                                                                                                    [?7l [?7h[44;23H(B[m(B[0;7mc(B[m(B[0;7mh(B[m(B[0;7me(B[m(B[0;7mc(B[m(B[0;7mk(B[m(B[0;7me(B[m(B[0;7md(B[m[J[37;40H[44d(B[0;7mSearch [checked]:                                                                                                                                                        [?7l [?7h[44;19H(B[m[J[3d[K[4;21Htextarea: -> m \.input-field,[5;25Hm \textarea.materialize-textarea,[6;29Hname: name, id: name, value:[K[7;32H[1K state.form[opts.id][name] or opts.doc?[name][8;21H    m \label, for: name, _.startCase name[9d[K[10;21Hrange: -> m \.input-field,[K[11;25Hm \label, for: name, _.startCase name[K[12;26H \.row[K[13;25Hm \input,[K[14;29Htype: \range, id: name, name: name,[K[15;28H[1K value: state.form[opts.id][name] or opts.doc?[name]?toString![16d[K[17;21Hcheckbox: -> m \div, attr.checkbox(name),[18;21H    m \h6.grey-text, _.startCase name[19;25HoptionList(name)map (j) -> m \.col,[20;28H[1K m \input,[21;32H[1K type: \checkbox, name: name,[22;32H[1K id: "#name#{j.value}", data: j.value[K[23;32H[1K checked:[K[24;36H[1K if stateTempGet(name)[25;41Hj.value.toString! in stateTempGet(name)value[26;36H[1K else if opts.doc?[name][27;40H[1K j.value.toString! in opts.doc[name][28;28H[1K m \label, for: "#name#{j.value}", _.startCase j.label[29;24H[1K m \.row[K[30d[K[31;21Hselect: -> m \.input-field,[K[32;25Hm \label, _.startCase name[K[33;25Hm \.row[34;24H[1K m \select, attr.select(name),[35;28H[1K m \option, value: '', _.startCase 'Select One'[36;28H[1K optionList(name)map (j) ->[K[37;32H[1K m \option, value: j.value, _.startCase j.label[38d[K[39;21Hradio: -> m \div,[40;24H[1K m \.row[K[41;24H[1K m \h6.grey-text, _.startCase name[42;24H[1K m \.row, optionList(name)map (j) -> m \.col,[43;28H[1K m \input, attr.radio name, j.value[23;33H[44d(B[0;7mSearch [checked]:                                                                                                                                                        [?7l [?7h[44;19H(B[m[?25l[44;76H[1K (B[0;7m[ Search Wrapped ](B[m[K[23;33H[?12l[?25h[3;21HdataTest = do ->[4;21H    a = usedSchema.newContext![5;25Ha.validate obj[K[6;25Ha._invalidKeys.map (i) ->[K[7;29HMaterialize.toast "#{i.name} - #{i.type}", 8000ms, \orange[8;25Hcheck obj, usedSchema[K[9;21HformTypes = (doc) ->[10;21H    insert: -> opts.collection.insert (doc or obj)[11;25Hupdate: -> opts.collection.update do[K[12;25H    {_id: opts.doc._id}, {$set: (doc or obj)}[13;26Hethod: -> Meteor.call opts.meteormethod, (doc or obj)[14;25H'update-pushArray': -> opts.collection.update {_id: opts.doc._id},[15;29H$push: "#{opts.scope}": $each: _.values obj[opts.scope][K[16;21Hif opts.hooks?before[17;21H    opts.hooks.before obj, (moded) -> formTypes(moded)[opts.type]![18;21Helse formTypes![opts.type]![K[19;21Hopts.hooks?after? obj[K[20d[K[21;13Hradio: (name, value) ->[K[22;17Htype: \radio, name: name, id: "#name#value"[K[23;17Hchecked: value is (stateTempGet(name)?value or opts.doc?[name])[24;17Honcreate: ({dom}) -> $ dom .on \change, ->[25;21Hstate.temp[opts.id]push {name, value}[K[26d[K[27;13Hselect: (name) ->[K[28;17Hname: name[K[29;17Hvalue: stateTempGet(name)?value or opts.doc?[name][30;17Honcreate: ({dom}) ->[31;21H$ dom .material_select![K[32;21H$ dom .on \change -> state.temp[opts.id]push do[33;25Hname: name, value: $ dom .val![34d[K[35;13Hcheckbox: (name) ->[K[36;17Honcreate: ({dom}) -> $ dom .on \change ->[37;21Hstate.temp[opts.id]push name: name, value:[K[38;25H_.map $("input:checked[name='#name']"), (i) ->[39;28H[1K i.attributes.data.nodeValue[40d[K[41;13HarrLen: (name, type) -> onclick: ->[K[42;17Hstate.arrLen[name] ?= 0[K[43;17Hnum = inc: 1, dec: -1[K[23;17H[44d[J[170G[44;1H[?1049l[?1l>]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ git diff
[?1h=[1mdiff --git a/both.ls b/both.ls[m[m
[1mindex a7f1af3..7b47105 100644[m[m
[1m--- a/both.ls[m[m
[1m+++ b/both.ls[m[m
[36m@@ -3,6 +3,7 @@[m [mcoll.contacts.allow do[m[m
        insert: -> true[m[m
        update: -> true[m[m
 schema.contacts = new SimpleSchema do[m[m
[32m+[m       [32mdeceased: type: Boolean[m[m
        name: type: String, label: 'Full Name'[m[m
        address: type: String, autoform: afFormGroup: class: 'col m6'[m[m
        mobile: type: Number, autoform: afFormGroup: class: 'col m6'[m[m
[1mdiff --git a/folder/funcs.ls b/folder/funcs.ls[m[m
[1mindex b8dc714..07d7414 100644[m[m
[1m--- a/folder/funcs.ls[m[m
[1m+++ b/folder/funcs.ls[m[m
[36m@@ -33,7 +33,7 @@[m [mif Meteor.isClient[m[m
                                        e.preventDefault![m[m
                                        temp = state.temp[opts.id]map (i) -> "#{i.name}": i.value[m[m
                                        filtered = _.filter e.target, (i) ->[m[m
[31m-                                               a = -> (i.value isnt \on) and i.name[m[m
[32m+[m                                               [32ma = -> i.value isnt \on and i.name[m[m
                                                b = -> theSchema(i)?autoform?type in <[radio checkbox select]>[m[m
                                                a! and not b![m[m
                                        obj = _.merge ... temp.concat _.map filtered, ({name, value}) -> if name[m[m
[36m@@ -48,7 +48,7 @@[m [mif Meteor.isClient[m[m
                                                                theSchema(normed)?autoValue name, temp.concat filtered[m[m
                                        makeArr = (name, value) ->[m[m
                                                if value is Object value then "#name":[m[m
[31m-                                                       if value[0][m[m
[32m+[m                                                       [32mif value.0[m[m
                                                                Object.keys value .map (key) ->[m[m
                                                                        makeArr key, value[key][m[m
                                                        else if value.getMonth then value[m[m
[36m@@ -83,19 +83,19 @@[m [mif Meteor.isClient[m[m
                        radio: (name, value) ->[m[m
                                type: \radio, name: name, id: "#name#value"[m[m
                                checked: value is (stateTempGet(name)?value or opts.doc?[name])[m[m
[31m-                               oncreate: -> $("input:radio##name#value[name='#name']")on do[m[m
[31m-                                       \change, -> state.temp[opts.id]push {name, value}[m[m
[32m+[m                               [32moncreate: ({dom}) -> $ dom .on \change, ->[m[m
[32m+[m                                       [32mstate.temp[opts.id]push {name, value}[m[m
 [m[m
:[K[K [KESCESC[KOO[KBB[K                        select: (name) ->[m[m
:[K[K [KESCESC[KOO[KBB[K                                name: name[m[m
:[K[K [KESCESC[KOO[KBB[K                                value: stateTempGet(name)?value or opts.doc?[name][m[m
:[K[K [KESCESC[KOO[KBB[K[31m-                               oncreate: ->[m[m
:[K[K [KESCESC[KOO[KBB[K[31m-                                       $ "select[name='#name']" .material_select![m[m
:[K[K [KESCESC[KOO[KBB[K[31m-                                       $ "select[name='#name']" .on \change -> state.temp[opts.id]push do[m[m
:[K[K [KESCESC[KOO[KBB[K[31m-                                               name: name, value: $ "select[name='#name']" .val![m[m
:[K[K [KESCESC[KOO[KBB[K[32m+[m                               [32moncreate: ({dom}) ->[m[m
:[K[K [KESCESC[KOO[KBB[K[32m+[m                                       [32m$ dom .material_select![m[m
:[K[K [KESCESC[KOO[KBB[K[32m+[m                                       [32m$ dom .on \change -> state.temp[opts.id]push do[m[m
:[K[K [KESCESC[KOO[KBB[K[32m+[m                                               [32mname: name, value: $ dom .val![m[m
:[K[K [KESCESC[KOO[KBB[K [m[m
:[K[K [KESCESC[KOO[KBB[K                        checkbox: (name) ->[m[m
:[K[K [KESCESC[KOO[KBB[K[31m-                               oncreate: -> $ "input[name='#name']" .on \change ->[m[m
:[K[K [KESCESC[KOO[KBB[K[32m+[m                               [32moncreate: ({dom}) -> $ dom .on \change ->[m[m
:[K[K [KESCESC[KOO[KBB[K                                        state.temp[opts.id]push name: name, value:[m[m
:[K[K [KESCESC[KOO[KBB[K                                                _.map $("input:checked[name='#name']"), (i) ->[m[m
:[K[K [KESCESC[KOO[KBB[K                                                        i.attributes.data.nodeValue[m[m
:[K[K [KESCESC[KOO[KBB[K[36m@@ -153,22 +153,22 @@[m [mif Meteor.isClient[m[m
:[K[K [KESCESC[KOO[KBB[K                                                        m \label, for: "#name#{j.value}", _.startCase j.label[m[m
:[K[K [KESCESC[KOO[KBB[K [m[m
:[K[K [KESCESC[KOO[KBB[K                                        other: ->[m[m
:[K[K [KESCESC[KOO[KBB[K[31m-                                               defaultInputTypes = text: String, number: Number, radio: Boolean, date: Date[m[m
:[K[K [KESCESC[KOO[KBB[K[32m+[m                                               [32mdefaultInputTypes = text: String, number: Number, checkbox: Boolean, date: Date[m[m
:[K[K [KESCESC[KOO[KBB[K                                                defaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[m[m
:[K[K [KESCESC[KOO[KBB[K                                                maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[m[m
:[K[K [KESCESC[KOO[KBB[K [m[m
:[K[K [KESCESC[KOO[KBB[K                                                if defaultType![m[m
:[K[K [KESCESC[KOO[KBB[K                                                        m \.input-field,[m[m
:[K[K [KESCESC[KOO[KBB[K                                                                class: schema.autoform?afFormGroup?class,[m[m
:[K[K [KESCESC[KOO[KBB[K[31m-                                                               m \label, for: i, _.startCase (schema?label or name)[m[m
:[K[K [KESCESC[KOO[KBB[K                                                                m \.row if defaultType!0 is \date[m[m
:[K[K [KESCESC[KOO[KBB[K                                                                m \input,[m[m
:[K[K [KESCESC[KOO[KBB[K                                                                        name: name, id: name,[m[m
:[K[K [KESCESC[KOO[KBB[K                                                                        type: schema.autoform?type or defaultType!0[m[m
:[K[K [KESCESC[KOO[KBB[K                                                                        value: do ->[m[m
:[K[K [KESCESC[KOO[KBB[K                                                                                date = if opts.doc?[i] then if defaultType!0 is \date[m[m
:[K[K [KESCESC[KOO[KBB[K[31m-                                                                                       moment(opts.doc[i])format \YYYY-MM-DD[m[m
:[K[K [KESCESC[KOO[KBB[K[32m+[m                                                                                       [32mmoment opts.doc[i] .format \YYYY-MM-DD[m[m
:[K[K [KESCESC[KOO[KBB[K                                                                                state.form[opts.id]?[name] or date or opts.doc?[i][m[m
:[K[K [KESCESC[KOO[KBB[K[32m+[m                                                               [32mm \label, for: i, _.startCase (schema?label or name)[m[m
:[K[K [KESCESC[KOO[KBB[K [m[m
:[K[K [KESCESC[KOO[KBB[K                                                else if schema.type is Object[m[m
:[K[K [KESCESC[KOO[KBB[K                                                        filtered = _.filter maped, (j) ->[m[m
:[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K [KESCESC[KOO[KBB[K[K[7m(END)[27m[K[K[?1l>]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ nano folder/funcs.ls 
[?1049h[1;44r(B[m[4l[?7h[?1h=[?1h=[?1h=[39;49m[?25l[39;49m(B[m[H[2J[44;78H(B[0;7m[ Reading File ][3d(B[m[44;77H(B[0;7m[ Read 217 lines ][3d(B[m[?12l[?25h[H[39;49m(B[0;7m  GNU nano 2.5.3                                          File: folder/funcs.ls                                                                                           [3;1H(B[m@_ = lodash[4d@coll = {}; @schema = {}; @state = {};[6dif Meteor.isClient[8;5H@m = require \mithril[10;5H@autoForm = (opts) ->[11;9Hscope = opts.scope and new SimpleSchema _.reduce opts.schema._schema,[12;13H(res, val, key) -> if (new RegExp "^#{opts.scope}")test(key)?[13;17H_.assign res, "#key": val[14;9H, {}[15;9HusedSchema = scope or opts.schema[16;9HtheSchema = (name) -> usedSchema._schema[name][17;9HomitFields = if opts.omitFields[18;13H_.pull (_.values usedSchema._firstLevelSchemaKeys), ...opts.omitFields[19;9HusedFields = omitFields or opts.fields or usedSchema._firstLevelSchemaKeys[20;9HoptionList = (name) ->[21;13HtheSchema(name)allowedValues?map (i) ->[22;17Hvalue: i, label: _.startCase i[23;13Hor theSchema(name)autoform?options[24;9Hstate.arrLen ?= {}; state.form ?= {}; state.temp ?= {}[25;9Hstate.form[opts.id] ?= {}; state.temp[opts.id] ?= [][26;9HstateTempGet = (field) -> if state.temp[opts.id][27;13H_.findLast state.temp[opts.id], (i) -> i.name is field[29;9Hattr =[30dform:[31donchange: ({target}) ->[32;21Hunless theSchema(target.name)?autoform?type in <[radio checkbox select]>[33;25Hstate.form[opts.id][target.name] = target.value[34;17Honsubmit: (e) ->[35;21He.preventDefault![36;21Htemp = state.temp[opts.id]map (i) -> "#{i.name}": i.value[37;21Hfiltered = _.filter e.target, (i) ->[38;25Ha = -> i.value isnt \on and i.name[39;25Hb = -> theSchema(i)?autoform?type in <[radio checkbox select]>[40;25Ha! and not b![41;21Hobj = _.merge ... temp.concat _.map filtered, ({name, value}) -> if name[42;25H_.reduceRight name.split(\.), ((res, inc) -> "#inc": res), do ->[43;29Hif value[3d[44d(B[0;7mSearch:                                                                                                                                                                  [?7l [?7h[44;9H(B[m(B[0;7md(B[m(B[0;7ma(B[m(B[0;7mt(B[m(B[0;7me(B[m[C(B[0;7m=(B[m[J[3;20H[1K radio: -> m \div,[4;24H[1K m \.row[K[5;25Hm \h6.grey-text, _.startCase name[6;24H[1K m \.row, optionList(name)map (j) -> m \.col,[7;29Hm \input, attr.radio name, j.value[8;28H[1K m \label, for: "#name#{j.value}", _.startCase j.label[10;20H[1K other: ->[11;24H[1K defaultInputTypes = text: String, number: Number, checkbox: Boolean, date: Date[12;24H[1K defaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[13;24H[1K maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[14d[K[15;24H[1K if defaultType![K[16;28H[1K m \.input-field,[K[17;32H[1K class: schema.autoform?afFormGroup?class,[18;32H[1K m \.row if defaultType!0 is \date[K[19;32H[1K m \input,[K[20;36H[1K name: name, id: name,[21;36H[1K type: schema.autoform?type or defaultType!0[22;36H[1K value: do ->[23;40H[1K date = if opts.doc?[i] then if defaultType!0 is \date[24;44H[1K moment opts.doc[i] .format \YYYY-MM-DD[25;40H[1K state.form[opts.id]?[name] or date or opts.doc?[i][26;32H[1K m \label, for: i, _.startCase (schema?label or name)[27d[K[28;25Helse if schema.type is Object[29;28H[1K filtered = _.filter maped, (j) ->[30;32H[1K a = -> _.includes j.name, "#name."[31;32H[1K b = -> name.split(\.)length+1 is j.name.split(\.)length[32;32H[1K a! and b![K[33;25H    m \.card, m \.card-content,[K[34;32H[1K m \.card-title, _.startCase name[35;32H[1K filtered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![36d[K[37;21H    else if schema.type is Array[K[38;25H    filtered = _.filter maped, (j) -> _.includes j.name, "#name.$"[39;25H    m \.card, m \.card-content,[K[40;32H[1K m \.card-title,[41;36H[1K m \p, _.startCase name[K[42;36H[1K m \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[43;36H[1K m \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[23;41H[34d[J[3;36H[1K m \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[4;36H[1K m \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[5;32H[1K filtered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[6;36H[1K iter = "#{_.replace j.name, \$, ''}#num"[7;36H[1K inputTypes(iter, j)[j?autoform?type or \other]![8d[K[9;17HinputTypes(i, theSchema i)[theSchema(i)?autoform?type or \other]![10d[K[11;13Hm \.row,[K[12;17Hm \.col, m \input.btn,[K[13;21Htype: \submit[K[14;21Hvalue: opts?buttonContent[15;21Hclass: opts?buttonClasses[16;17Hm \.col, m \input.btn,[K[17;21Htype: \reset[K[18;21Hvalue: opts?reset?content[K[19;21Hclass: opts?reset?classes[20d[K[21;5H@autoTable = (opts) ->[K[22;9Hattr =[K[23drowEvent: (doc) ->[K[24;17Honclick: -> opts.rowEvent.onclick doc[K[25;17Hondblclick: -> opts.rowEvent.ondblclick doc[K[26d[K[27;9Hview: -> m \table,[28;13Hm \thead,[K[29;17Hm \tr, opts.fields.map (i) ->[K[30;21Hm \th, _.startCase i[K[31;13Hm \tbody, opts.collection.find!fetch!map (i) ->[K[32;17Hm \tr, attr.rowEvent(i), opts.fields.map (j) ->[33;21Hm \td, i[j][K[23;31H[3;21Hradio: -> m \div,[K[4;25Hm \.row[K[5;25Hm \h6.grey-text, _.startCase name[K[6;25Hm \.row, optionList(name)map (j) -> m \.col,[K[7;29Hm \input, attr.radio name, j.value[K[8;29Hm \label, for: "#name#{j.value}", _.startCase j.label[9d[K[10;21Hother: ->[11;24H[1K defaultInputTypes = text: String, number: Number, checkbox: Boolean, date: Date[12;24H[1K defaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[13;21H    maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[14d[K[15;21H    if defaultType![K[16;28H[1K m \.input-field,[17;32H[1K class: schema.autoform?afFormGroup?class,[18;32H[1K m \.row if defaultType!0 is \date[19;32H[1K m \input,[K[20;37Hname: name, id: name,[21;36H[1K type: schema.autoform?type or defaultType!0[22;36H[1K value: do ->[23;40H[1K date = if opts.doc?[i] then if defaultType!0 is \date[24;44H[1K moment opts.doc[i] .format \YYYY-MM-DD[25;40H[1K state.form[opts.id]?[name] or date or opts.doc?[i][26;33Hm \label, for: i, _.startCase (schema?label or name)[27d[K[28;24H[1K else if schema.type is Object[29;28H[1K filtered = _.filter maped, (j) ->[30;32H[1K a = -> _.includes j.name, "#name."[31;32H[1K b = -> name.split(\.)length+1 is j.name.split(\.)length[32;32H[1K a! and b![K[33;28H[1K m \.card, m \.card-content,[34;33Hm \.card-title, _.startCase name[35;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![37;25Helse if schema.type is Array[38;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[39;29Hm \.card, m \.card-content,[40;33Hm \.card-title,[41;37Hm \p, _.startCase name[42;37Hm \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), \-rem[43;37Hm \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[23;41H[24d[25d[26d[27d[28;41H[29d[30d[31d[32d[33d[34d[35d[36d[37;41H[38d[39d[40d[41d[42d[43d[3d[M[43;33Hfiltered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[43;41H[3d[M[43;37Hiter = "#{_.replace j.name, \$, ''}#num"[43;41H[3d[M[43;37HinputTypes(iter, j)[j?autoform?type or \other]![43;41H[3d[M[43d[3d[M[43;17HinputTypes(i, theSchema i)[theSchema(i)?autoform?type or \other]![43;41H[3d[M[43d[2d[M[43;13Hm \.row,[3d[M[43;17Hm \.col, m \input.btn,[3d[M[43;21Htype: \submit[3d[M[43;21Hvalue: opts?buttonContent[41G[3d[M[43;21Hclass: opts?buttonClasses[41G[2d[M[43;17Hm \.col, m \input.btn,[3d[M[43;21Htype: \reset[3d[M[43;21Hvalue: opts?reset?content[41G[3d[M[43;21Hclass: opts?reset?classes[41G[3d[M[43d[3d[M[43;5H@autoTable = (opts) ->[3d[M[43;9Hattr =[3d[M[43;13HrowEvent: (doc) ->[3d[M[43;17Honclick: -> opts.rowEvent.onclick doc[43;41H[3d[M[43;17Hondblclick: -> opts.rowEvent.ondblclick doc[43;41H[3d[M[43d[3d[8M[36;9Hview: -> m \table,[37;13Hm \thead,[38;17Hm \tr, opts.fields.map (i) ->[39;21Hm \th, _.startCase i[40;13Hm \tbody, opts.collection.find!fetch!map (i) ->[41;17Hm \tr, attr.rowEvent(i), opts.fields.map (j) ->[42;21Hm \td, i[j][43d[3d[K[4;21Hselect: -> m \.input-field,[K[5;25Hm \label, _.startCase name[K[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[K[9;29HoptionList(name)map (j) ->[K[10;36Hoption, value: j.value, _.startCase j.label[11d[K[12;21Hradio: -> m \div,[K[13;25Hm \.row[K[14;25Hm \h6.grey-text, _.startCase name[K[15;25Hm \.row, optionList(name)map (j) -> m \.col,[K[16;29Hm \input, attr.radio name, j.value[K[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[18d[K[19;21Hother: ->[20;24H[1K defaultInputTypes = text: String, number: Number, checkbox: Boolean, date: Date[21;24H[1K defaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is schema.type[22;21H    maped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": key[23d[K[24;21H    if defaultType![K[25;28H[1K m \.input-field,[26;32H[1K class: schema.autoform?afFormGroup?class,[27;32H[1K m \.row if defaultType!0 is \date[28;32H[1K m \input,[K[29;37Hname: name, id: name,[30;36H[1K type: schema.autoform?type or defaultType!0[31;36H[1K value: do ->[32;40H[1K date = if opts.doc?[i] then if defaultType!0 is \date[33;44H[1K moment opts.doc[i] .format \YYYY-MM-DD[34;40H[1K state.form[opts.id]?[name] or date or opts.doc?[i][35;33Hm \label, for: i, _.startCase (schema?label or name)[36d[K[37;24H[1K else if schema.type is Object[38;28H[1K filtered = _.filter maped, (j) ->[39;32H[1K a = -> _.includes j.name, "#name."[40;32H[1K b = -> name.split(\.)length+1 is j.name.split(\.)length[41;32H[1K a! and b![K[42;28H[1K m \.card, m \.card-content,[43;33Hm \.card-title, _.startCase name[A[A[A[A[A[A[A[A[A[35d[36d[35;85H[A[A[A!0[31;49H[30;80H[31;49H[32;85H[31;49H[30;80H[29;58H[30;80H[29;58H[M[1;161H(B[0;7mModified[43;33H(B[mfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![29d[30d7[30;43r8M[1;44r[30;37Hname: name, id: name,[31d[A[30;58H[31d[M[30;93Hvalue: do ->[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \other]![30;58H[4P[4P[4P[4P[4P[4P[4P[4P[3P value: do ->[30;59H[44d(B[0;7mFile Name to Write: folder/funcs.ls                                                                                                                                      [?7l [?7h[44;36H(B[m[?25l[44;75H[39;49m(B[m[1K (B[0;7m[ Wrote 216 lines ](B[m[K[30;59H[?12l[?25h[1;161H(B[0;7m        [30;59H(B[m[44;1H[?1049l[?1l>[?1049h[1;34r[?12l[?25h[39;49m(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 2.5.3                                          File: f[4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Se[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.star[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.c[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.s[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number:[21;25HdefaultType = -> _.find (_.toPairs defaul[22;25Hmaped = _.map usedSchema._schema, (val, k[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGrou[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or[30;37Hname: name, id: name, value:[31;41Hdate = if opts.doc?[i] th[32;45Hmoment opts.doc[i] .f[33;41Hstate.form[opts.id]?[name[34;33Hm \label, for: i, _.startCase (s[?7lc[?7h[30;59H[?1h=[?1h=[?1h=[H[2J(B[0;7m  GNU nano 2.5.3                                          File: f[4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Se[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.star[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.c[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.s[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number:[21;25HdefaultType = -> _.find (_.toPairs defaul[22;25Hmaped = _.map usedSchema._schema, (val, k[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGrou[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or[30;37Hname: name, id: name, value:[31;41Hdate = if opts.doc?[i] th[32;45Hmoment opts.doc[i] .f[33;41Hstate.form[opts.id]?[name[34;33Hm \label, for: i, _.startCase (s[?7lc[?7h[30;59H[1;24H(B[0;7mFile: folder/funcs.ls[59G       [8;65H(B[m$[10;65H$[15;65H$[17;65H$[20;65H$[21;65H$[22;65H$[26;65H$[29;65H$[30;65H$[31;65H$[32;65H$[33;65H$[30;59H[34;1H[?1049l[?1l>[?1049h[1;44r[?12l[?25h[39;49m(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 2.5.3       File: folder/funcs.ls                     [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'S$[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.sta$[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.$[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.$[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number$[21;25HdefaultType = -> _.find (_.toPairs defau$[22;25Hmaped = _.map usedSchema._schema, (val, $[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGro$[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type o$[30;37Hname: name, id: name, value:$[31;41Hdate = if opts.doc?[i] t$[32;45Hmoment opts.doc[i] .$[33;41Hstate.form[opts.id]?[nam$[34;33Hm \label, for: i, _.startCase (sc[30;59H[?1h=[?1h=[?1h=[H[2J(B[0;7m  GNU nano 2.5.3       File: folder/funcs.ls                     [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'S$[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.sta$[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.$[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.$[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number$[21;25HdefaultType = -> _.find (_.toPairs defau$[22;25Hmaped = _.map usedSchema._schema, (val, $[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGro$[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type o$[30;37Hname: name, id: name, value:$[31;41Hdate = if opts.doc?[i] t$[32;45Hmoment opts.doc[i] .$[33;41Hstate.form[opts.id]?[nam$[34;33Hm \label, for: i, _.startCase (sc[30;59H[1;24H(B[0;7m       File: folder/funcs.ls[1;66H                    [8;65H(B[melect One'[10;65HrtCase j.label[15;65Hcol,[17;65HstartCase j.label[20;65H: Number, checkbox: $[21;65HltInputTypes), (j) -$[22;65Hkey) -> _.assign val$[26;65Hup?class,[29;65Hr defaultType!0[30;65H do ->[31;65Hhen if defaultType!0$[32;65Hformat \YYYY-MM-DD[33;65He] or date or opts.d$[34;66Hhema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)len$[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform$[30;59H[44;1H[?1049l[?1l>[?1049h[1;48r[?12l[?25h[39;49m(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 2.5.3              File: folder/funcs.ls                                  [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.startCase j.label[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.col,[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number: Number, checkbox: $[21;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -$[22;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val$[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGroup?class,[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or defaultType!0[30;37Hname: name, id: name, value: do ->[31;41Hdate = if opts.doc?[i] then if defaultType!0$[32;45Hmoment opts.doc[i] .format \YYYY-MM-DD[33;41Hstate.form[opts.id]?[name] or date or opts.d$[34;33Hm \label, for: i, _.startCase (schema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)len$[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform$[30;59H[?1h=[?1h=[?1h=[H[2J(B[0;7m  GNU nano 2.5.3              File: folder/funcs.ls                                  [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.startCase j.label[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.col,[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number: Number, checkbox: $[21;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -$[22;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val$[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGroup?class,[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or defaultType!0[30;37Hname: name, id: name, value: do ->[31;41Hdate = if opts.doc?[i] then if defaultType!0$[32;45Hmoment opts.doc[i] .format \YYYY-MM-DD[33;41Hstate.form[opts.id]?[name] or date or opts.d$[34;33Hm \label, for: i, _.startCase (schema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)len$[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform$[30;59H[1;31H(B[0;7m    File: folder/funcs.ls[1;86H            [20;85H(B[mBoolean, dat$[21;85H> j.1 is sch$[22;85H, "#name": k$[31;85H is \date[33;85Hoc?[i][39;85Hgth[43;85H?type or \ot$[45;25Helse if schema.type is Array[46;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[47;29Hm \.card, m \.card-content,[30;59H[48;1H[?1049l[?1l>[?1049h[1;51r[?12l[?25h[39;49m(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 2.5.3                  File: folder/funcs.ls                                          [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.startCase j.label[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.col,[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number: Number, checkbox: Boolean, dat$[21;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is sch$[22;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": k$[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGroup?class,[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or defaultType!0[30;37Hname: name, id: name, value: do ->[31;41Hdate = if opts.doc?[i] then if defaultType!0 is \date[32;45Hmoment opts.doc[i] .format \YYYY-MM-DD[33;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][34;33Hm \label, for: i, _.startCase (schema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)length[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \ot$[45;25Helse if schema.type is Array[46;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[47;29Hm \.card, m \.card-content,[30;59H[?1h=[?1h=[?1h=[H[2J(B[0;7m  GNU nano 2.5.3                  File: folder/funcs.ls                                          [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.startCase j.label[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.col,[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number: Number, checkbox: Boolean, dat$[21;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is sch$[22;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": k$[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGroup?class,[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or defaultType!0[30;37Hname: name, id: name, value: do ->[31;41Hdate = if opts.doc?[i] then if defaultType!0 is \date[32;45Hmoment opts.doc[i] .format \YYYY-MM-DD[33;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][34;33Hm \label, for: i, _.startCase (schema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)length[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \ot$[45;25Helse if schema.type is Array[46;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[47;29Hm \.card, m \.card-content,[30;59H[48;33Hm \.card-title,[49;37Hm \p, _.startCase name[50;37Hm \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), $[30;59H[51;1H[?1049l[?1l>[?1049h[1;67r[?12l[?25h[39;49m(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 2.5.3                  File: folder/funcs.ls                                          [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.startCase j.label[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.col,[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number: Number, checkbox: Boolean, dat$[21;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is sch$[22;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": k$[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGroup?class,[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or defaultType!0[30;37Hname: name, id: name, value: do ->[31;41Hdate = if opts.doc?[i] then if defaultType!0 is \date[32;45Hmoment opts.doc[i] .format \YYYY-MM-DD[33;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][34;33Hm \label, for: i, _.startCase (schema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)length[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \ot$[45;25Helse if schema.type is Array[46;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[47;29Hm \.card, m \.card-content,[48;33Hm \.card-title,[49;37Hm \p, _.startCase name[50;37Hm \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), $[30;59H[?1h=[?1h=[?1h=[H[2J(B[0;7m  GNU nano 2.5.3                  File: folder/funcs.ls                                          [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.startCase j.label[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.col,[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number: Number, checkbox: Boolean, dat$[21;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) -> j.1 is sch$[22;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val, "#name": k$[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGroup?class,[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or defaultType!0[30;37Hname: name, id: name, value: do ->[31;41Hdate = if opts.doc?[i] then if defaultType!0 is \date[32;45Hmoment opts.doc[i] .format \YYYY-MM-DD[33;41Hstate.form[opts.id]?[name] or date or opts.doc?[i][34;33Hm \label, for: i, _.startCase (schema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)length[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?type or \ot$[45;25Helse if schema.type is Array[46;29Hfiltered = _.filter maped, (j) -> _.includes j.name, "#name.$"[47;29Hm \.card, m \.card-content,[48;33Hm \.card-title,[49;37Hm \p, _.startCase name[50;37Hm \.right.orange.btn.waves-effect, attr.arrLen(name, \dec), $[30;59H[1;35H(B[0;7m             File: folder/funcs.ls[1;98H                                       [20;97H(B[me: Date[21;97Hema.type[22;97Hey[43;97Hher]![50;97H\-rem[51;37Hm \.right.btn.waves-effect, attr.arrLen(name, \inc), \+add[52;33Hfiltered.map (j) -> [0 to (state.arrLen[name] or 0)]map (num) ->[53;37Hiter = "#{_.replace j.name, \$, ''}#num"[54;37HinputTypes(iter, j)[j?autoform?type or \other]![56;17HinputTypes(i, theSchema i)[theSchema(i)?autoform?type or \other]![58;13Hm \.row,[59;17Hm \.col, m \input.btn,[60;21Htype: \submit[61;21Hvalue: opts?buttonContent[62;21Hclass: opts?buttonClasses[63;17Hm \.col, m \input.btn,[64;21Htype: \reset[65;21Hvalue: opts?reset?content[66;21Hclass: opts?reset?classes[30;59H[67;1H[?1049l[?1l>[?1049h[1;44r[?12l[?25h[39;49m(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 2.5.3                               File: folder/funcs.ls                 [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.startCase j.label[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.col,[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number: Number, checkbox: B[21;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) ->[22;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val,[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGroup?class,[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or defaultType!0[30;37Hname: name, id: name, value: do ->[31;41Hdate = if opts.doc?[i] then if defaultType!0[32;45Hmoment opts.doc[i] .format \YYYY-MM-DD[33;41Hstate.form[opts.id]?[name] or date or opts.do[34;33Hm \label, for: i, _.startCase (schema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)leng[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?[30;59H[?1h=[?1h=[?1h=[H[2J(B[0;7m  GNU nano 2.5.3                               File: folder/funcs.ls                 [4;21H(B[mselect: -> m \.input-field,[5;25Hm \label, _.startCase name[6;25Hm \.row[7;25Hm \select, attr.select(name),[8;29Hm \option, value: '', _.startCase 'Select One'[9;29HoptionList(name)map (j) ->[10;33Hm \option, value: j.value, _.startCase j.label[12;21Hradio: -> m \div,[13;25Hm \.row[14;25Hm \h6.grey-text, _.startCase name[15;25Hm \.row, optionList(name)map (j) -> m \.col,[16;29Hm \input, attr.radio name, j.value[17;29Hm \label, for: "#name#{j.value}", _.startCase j.label[19;21Hother: ->[20;25HdefaultInputTypes = text: String, number: Number, checkbox: B[21;25HdefaultType = -> _.find (_.toPairs defaultInputTypes), (j) ->[22;25Hmaped = _.map usedSchema._schema, (val, key) -> _.assign val,[24;25Hif defaultType![25;29Hm \.input-field,[26;33Hclass: schema.autoform?afFormGroup?class,[27;33Hm \.row if defaultType!0 is \date[28;33Hm \input,[29;37Htype: schema.autoform?type or defaultType!0[30;37Hname: name, id: name, value: do ->[31;41Hdate = if opts.doc?[i] then if defaultType!0[32;45Hmoment opts.doc[i] .format \YYYY-MM-DD[33;41Hstate.form[opts.id]?[name] or date or opts.do[34;33Hm \label, for: i, _.startCase (schema?label or name)[36;25Helse if schema.type is Object[37;29Hfiltered = _.filter maped, (j) ->[38;33Ha = -> _.includes j.name, "#name."[39;33Hb = -> name.split(\.)length+1 is j.name.split(\.)leng[40;33Ha! and b![41;29Hm \.card, m \.card-content,[42;33Hm \.card-title, _.startCase name[43;33Hfiltered.map (j) -> inputTypes(j.name, j)[j?autoform?[30;59H[1;31H(B[0;7mFile: folder/funcs.ls                 [20;85H(B[m$[21;85H$[22;85H$[31;85H$[33;85H$[39;85H$[43;85H$[30;59H[44;85H[44;1H[?1049l[?1l>]0;autoform[01;32mriky@riky-X201EV[00m:[01;34m~/Meteor/autoform[00m$ exit
exit

Script done on Min 24 Jun 2018 06:48:16  WIB
